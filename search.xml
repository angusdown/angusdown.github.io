<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>electronics-right-to-repair</title>
    <url>/2021/07/17/electronics-right-to-repair/</url>
    <content><![CDATA[<h2 id="历史">历史</h2>
<p>1924年，美国汽车市场开始饱和。为了保持销量，通用汽车公司高管小阿尔弗雷德·P·斯隆 (Alfred P. Sloan Jr.)建议每年更改车型设计，以说服车主每年购买新的替代品，并由哈雷·厄尔( Harley Earl)和艺术与色彩部门 (Art and Color Section)领导更新外观。这一战略对汽车工业、产品设计领域乃至整个美国经济产生了深远的影响。小玩家无法保持每年重新设计风格的速度和费用，从而形成了大公司的垄断地位。并且经过不断发展，有了多样的手段形态。 <a id="more"></a></p>
<h3 id="项目性报废计划报废">项目性报废（计划报废）</h3>
<p>这是一种消费主义下的工业策略阴谋，通过有意甚至刻意为产品设计有限的使用寿命或一些脆弱的缺陷，令产品在一定时间后（如过保），或逐渐减少功能或突然停止功能，导致产品无法正常工作，从而迫使人们购买更换产品。</p>
<h3 id="几种报废情况">几种报废情况</h3>
<h4 id="阻止维修">阻止维修</h4>
<p>例如苹果公司的“防篡改”设计、“pentalobe螺丝”、内置不可更换式电池等。在带有不可打开后盖（用户不可更换电池）的设备上，手动（强制）更换电池可能会导致永久性损坏，包括由于防水密封件损坏而失去防水性能，以及由于必须在靠近精密组件的地方撬开没有强力粘合剂的电池，因此可能会对手机主板造成严重甚至无法修复的损坏。维修所需零件要么制造商无法提供，要么价格昂贵，以至于产品维修起来不经济，其目的是使维修成本与更换成本相当，甚至从根本上阻止任何形式的产品维修，让客户在产品出现故障后必须购买全新的产品。</p>
<h4 id="感知过时">感知过时</h4>
<p>许多产品主要是出于美观而不是功能原因。这样的产品通过不断引入新的美学，重新定位或停止旧设计，即使原始产品保持了完整的功能。比如苹果公司会定期发布稍微更新的产品，引入新配色吸引人们升级，并强调其作为身份象征的价值。</p>
<h4 id="软件系统更新">软件系统更新</h4>
<p>比如故意使旧版本的软件无法使用，即使它们在技术上能够继续按预期工作，软件公司也会故意放弃对旧技术的支持，迫使用户购买新软件产品以取代过时的产品。如iPhone出现的Error 53丑闻，由独立商店修理过iPhone的Touch ID主页按钮的用户在更新iOS后很快遇到了“错误53”，这几乎使设备变了砖。</p>
<h4 id="法律约束">法律约束</h4>
<p>比如大公司推动立法破坏产品的可用性，以及通过提供利益来促进购买新产品。</p>
<h2 id="维修权">维修权</h2>
<p>当前虽然修理自己的产品不违法，但没有法律框架来确保个人可以这样做。而且不能指望市场来解决这个问题。如果制造商销售新产品比维修更有利可图，那么只有立法才能确保制造商使个人能够维修自己的产品，或者通过提供必要的工具和信息来自行维修，因为个人并不总是有权获得维修产品所需的维修说明、备件或专用工具。个人维修权在制造商生产不可维修产品的权利开始时就已经停止。因此维修权就是要消费者具有修理和修改他们自己的电子设备的权力，并要求硬件厂商公开自己产品的原理图纸，出售备用零件。只有制造商才能维修智能手机等电子设备的情况违反了反托拉斯法。</p>
<h3 id="背景">背景</h3>
<p>维修权的概念一般来自美国。马萨诸塞州于2012年通过了美国首部《机动车所有人修理权法案》，该法案要求汽车制造商提供必要的文件和信息，以允许任何人修理他们的车辆。虽然未在联邦层面获得通过，但主要汽车贸易组织签署了一份备忘录，同意从2018年汽车年开始在所有50个州遵守马萨诸塞州的法律。此后，该州通过了2012年法律修正案，作为2020年大选的一部分，以消除允许特斯拉公司等公司绕过原始法律的法律漏洞。修订后的法律要求汽车制造商在2022发布年度支持开放数据平台，车主和独立维修店可以通过移动应用程序或类似方式访问该平台，并提供与其认证维修人员可以访问的相同信息。 受这种方法的启发，数字维修联盟(DRRC)，后来更名为维修协会(TRA)，于2013年成立，将相同的原则应用于电子产品。</p>
<h3 id="尝试立法">尝试立法</h3>
<p>随着电子产品变得越来越复杂，许多电子制造商要求由原始设备制造商 (OEM) 自己或通过其授权供应商之一进行维修或完成维修的部件，这使得该过程对消费者而言既昂贵又繁重。例如，Apple为其销售的产品提供Genius Bar服务和支持。如果禁止任何第三方拆卸有形商品，消费者修理该商品的权利也是非法的（即使公司已经破产或停止服务）。</p>
<p>制造商还能够成功地使用诸如数字千年版权法案(DMCA) 之类的立法来防止消费者修改他们的设备。一些人认为，制造商的这种限制性方法为消费品制造了有计划的过时，从而迫使消费者升级他们的设备并确保制造商的收入。TRA认为有必要保护消费者的权利。其首批活动之一是在2014年推广《解锁消费者选择和无线竞争法案》，该法案废除了美国版权局做出的一项裁决，该裁决以其他方式阻止消费者解锁他们的手机。</p>
<p>TRA与南达科他州、纽约州、明尼苏达州和马萨诸塞州四个州合作，于2014年至2016年在这些州引入“维修权”法律，要求原始设备制造商为消费者和第三方提供所需的信息和文件修理店修理他们的产品。虽然纽约在2015年2月提出了它的法案，但没有看到太多进展，提交给纽约州参议院审议并未通过。事实上苹果曾游说反对该法案的通过。该公司同样游说停止马萨诸塞州的法案。加利福尼亚州州代表苏珊·埃格曼 (Susan Eggman)试图在2019年初为该州引入类似的立法，但在苹果等公司以及CompTIA和娱乐软件协会等贸易团体游说其他立法者以确保此类法案不会通过后被迫撤回该法案，认为这种“维修权”法案可能会导致人们在尝试维修电子设备时伤害自己，并且黑客将漏洞插入修复后的设备中，从而影响用户的隐私和安全。 2021年3月，Rossmann启动了一项众筹活动，使用GoFundMe平台筹集了600万美元，发起一项直接投票计划，以保护马萨诸塞州消费者的维修权。</p>
<h3 id="维修权运动">维修权运动</h3>
<h4 id="美国">美国</h4>
<p>发现苹果公司2016年反对这些法案后，由TRA领导的更大的“维修权”运动开始发展。该运动得到了农业部门的推动，许多农民发现，如果不使用制造商的高成本维修服务，他们就无法合​​法地修理从约翰迪尔等公司购买的拖拉机或其他农业设备。他们在美国农场局联合会游说提供从DMCA必要的豁免，允许农民自己修装备。TRA继续游说许多州的州法案，特别是在中西部，赋予消费者维修设备的权利。据《时代》杂志报道，苹果、约翰迪尔和AT&amp;T等公司游说反对这些法案。</p>
<p>2017 年底，Apple旧款iPhone机型的用户发现更新iOS后，手机的运行速度降低了。苹果最初回应称，该软件的目标是防止旧型号的锂离子电池负担过重，以避免手机意外关机。许多人声称苹果故意破坏旧款iPhone的性能，以迫使客户更频繁地购买新机型。作为回应，Apple允许用户在iOS更新中禁用电池节流功能，但仅限于手机因负载过重而关机的情况。这种限制的基本原理，即如果所讨论的功能的功能是防止这种关闭，首先如何发生这种关闭，从来没有令人信服的争论。iOS 功能更改也只是一种方式，这意味着禁用该功能的用户发现，一旦禁用，就无法重新激活它。这有效地阻止了用户执行任何可以证明该功能提供的所谓好处的来回切换。此外，Apple 允许受影响 iPhone 的用户获得更换手机电池的服务，以降低服务成本（US $ 30相比，美国79 $）在未来6个月。然而，“维修权”运动指出，如果苹果允许消费者购买第三方电池，并拥有以较低成本更换电池的说明，这种情况本来可以得到处理。</p>
<p>随着2018年初的新州国会任期，到2018年1月中旬，已有17个州引入了维修权立法；加州在三月份加入了他们自己的州法案。作为回应，2018年2月，代表大多数主要农业设备制造商的设备制造商协会和设备经销商协会同意了一份与汽车行业类似的备忘录，向用户提供其农业设备的综合信息。然而，2018年9月，远西设备经销商协会与加州农场局达成妥协，虽然设备制造商将提供手册、产品指南、诊断工具、机载软件接口，从而允许农民进行物理维修，但这并不扩展到设备上的任何实际软件或计算机化系统.该协会声称他们需要防止对软件的未经授权的访问，以防止用户更改设置以不安全的方式操作并保护设备上的软件，并声明修复权不应被视为软件权。由于加利福尼亚农业局已同意协会的条款，因此加州的任何维修立法的权利都不太可能包括农业设备。</p>
<p>2018年4月，联邦贸易委员会向六家汽车、消费电子和视频游戏机制造商发出通知，后来通过信息自由法案的要求披露了现代、华硕、HTC、微软、索尼和任天堂，声明他们的保修做法可能违反Magnuson-Moss 保修法案. FTC明确指出，如果消费者破坏了设备包装上的保修标签或封条、使用第三方更换零件或使用第三方维修服务，则告知他们保修无效是一种欺骗性做法，因为这些条款仅在制造商提供免费保修服务或更换零件情况下有效。在此通知之后，索尼和任天堂都发布了更新的保修声明。</p>
<p>2018年4月，美国公共利益研究小组发表声明，为Eric Lundgren因创建“恢复磁盘”以延长计算机寿命而被判刑一事进行辩护。</p>
<p>在美国国会图书馆，作为其为期三年的豁免DMCA审查的一部分，批准于2018年10月份的豁免将允许一个在陆地车辆，智能手机和家电产品用于维护的能力绕过版权保护机制（“使其按照其原始规格工作以及对该设备或系统授权的那些规格的任何更改”）或维修（“根据其原始规格和任何更改将设备或系统恢复到工作状态为该设备或系统授权的那些规格”）设备。</p>
<p>参议员伊丽莎白·沃伦( Elizabeth Warren ) 在2019年3月制定与农业相关的立法计划时表示，她打算通过立法来确认维修农场设备的权利，并可能将其扩展到其他电子设备。</p>
<p>在COVID-19 大流行期间，医疗设备对许多医院来说变得至关重要，iFixit和CalPIRG（公共利益研究小组的加利福尼亚分支）致力于出版已知最大的医疗设备手册和服务指南集，使用在无法获得制造商直接信息的情况下，医院和医疗机构的信息，以确保在大流行期间可以快速维修此类设备。iFixit 发现，与消费电子产品一样，一些更昂贵的医疗设备已经使用手段使最终用户难以进行非常规维修并需要授权维修过程，这在大流行的紧急情况下是不可接受的。</p>
<p>2020年8月6日，参议员Ron Wyden和众议员Yvette Clarke提出了2020年关键医疗基础设施维修权法案（S. 4473，HR 7956），该法案的重点是防止卫生专业人员在尝试时受到版权法的约束修理设备，使“COVID-19 援助”更容易。</p>
<p>在美国联邦贸易委员会（FTC）发布的一份报告2021年5月“坭兴修复”到美国国会，列出各地的企业的政策问题，关于消费品极限维修，这违反了贸易法考虑，并概述了可以做的步骤更好地执行这一点。这包括相关行业的自我监管，以及扩大现有法律，例如Magnuson-Moss 保修法或新法律，以使 FTC 更好地执法，以保护消费者免受过度热心的维修限制。这些维修权法律最终将使您能够在不使保修无效的情况下打开设备吗？从技术上讲，您始终可以自己破坏打开的消费类电子产品而不会失去保修。多亏了1975年的《马格努森-莫斯（Magnuson-Moss）保修法案》，公司仅凭您自己修理或修改某些东西就使保修无效，这实际上是非法的。他们必须证明您进行DIY维修或改装导致设备中的其他故障。至少从法律角度而言，在许多消费电子产品上看到的那些可怕的保修标贴实际上是毫无意义的。 2021年7月9日，拜登总统签署行政命令14036，“促进美国经济中的竞争”，这是整个行政部门的一系列举措。其中包括向FTC指示制定规则，以防止制造商阻止业主或独立维修店进行维修。白宫经济顾问布赖恩·迪斯表示，这一措施将可以增加竞争性，并且降低美国家庭的物价成本。</p>
<h4 id="欧洲">欧洲</h4>
<p>欧盟于 2019 年 10 月通过了立法，要求在 2021 年3 月 1 日生效的新规之后，电器制造商能够在制造后十年内向专业维修人员提供更换零件。然而，该立法并未涉及与维修权相关的其他方面，活动人士指出，这仍然限制了消费者自行维修的能力。英国政府出台了维修权法，该法于2021年7月 1日生效。根据该法，电子设备制造商必须能够为消费者提供“简单而安全”的维修备件，同时要求制造商将其他零件提供给专业维修店，用于更复杂的零件。该法律为公司提供了两年的宽限期以使其合规。</p>
<h4 id="厂商">厂商</h4>
<p>当维修权法案开始被讨论时，2021年3月28日，苹果独立维修服务提供商启动，该计划可让维修服务提供商获得原装零件、工具、维修手册和诊断方法，从而处理已过保修期产品的维修服务。独立维修商计划或正是苹果在反垄断大潮，以及公平维修法案（Fair Repair Act）风起云涌之下的一种必然选择。然而有部分维修店抱怨，苹果的计划需要苹果认证的技术人员来执行维修，同时某些零件也不会提供给独立维修店。</p>
<p>来自彭博社的报道显示，仅2021年美国就有27个州考虑制定“维修权”法案，虽然美国各州都在积极推进维修权的立法工作，但包括苹果、微软、亚马逊和谷歌在内的科技企业则在积极采取各种措施，来游说政府阻止“维修权”法案生效。其中微软总裁兼首席法务官Brad Smith也与美国各州讨论了关于“维修权”的问题，Brad Smith称“维修权”的立法对于微软的发展是一种危害。反对“维修权”立法团体的 TechNet 的副总裁 David Edmonson 表示，允许未经审查的第三方获得软件、工具、零件和敏感的信息，将危及消费者设备的安全，并使消费者面临被诈骗的风险。这些公司的反对目前初见成效，美国 27 个州的立法者决定不对“维修权”立法。</p>
<p>但在许多观点看来，这并不代表着厂商就有权利代替用户做出决定，毕竟无论是设备损坏还是在维修时伤害自己，都是消费者自己的权利。至于说所谓的安全问题，这更有些站不住脚了，如今即便没有维修权法案存在，苹果、谷歌、微软实际上也拦不住消费者将自己的设备送至第三方维修商处，或者有恶意的黑客自行购买后进行破解。 许多业内人士看来，苹果等企业反对维修权法案，更准确的说是其实是为了反对该法案要求公开产品原理图等信息的行为。事实上在很早前，消费者购买电视、电脑、收音机，以及其他电子设备时，有相当多的厂商都会附赠<strong>原理图</strong>。但随着电子产品日益高度集成化，产品原理图之中的信息量也越来越大了，特别是EMC设计等更是各家公司的“不传之秘”，同时也是非常有价值的资产。曾有俄罗斯黑客组织REvil入侵了苹果代工方广达电脑的服务器，获取了新款MacBook的原理图等文件，为此向广达和苹果方面索取5000万美元的赎金。并且产品原理图如今的重要性在于，随着技术的进步和知识的扩散，电子产品的设计和制造并不是像数十年前一般高不可攀。而一旦维修权法案成为定局，这些企业公开产品图就意味着向类似“华强北”这样的地方提供了“弹药”。要知道即便是在苹果严防死守的情况下，山寨厂商出品的AirPods等产品都已经可以以假乱真，如果有了官方公布的原理图，或许就不是以假乱真而是“官方正版”了。再加上维修权的正当化，就必然导致第三方企业获得翻新产品的能力，这就意味着包括苹果等大厂严丝合缝的生态就被打开了一个巨大的缺口，市场将会出现不在其控制之下，但实际体验又接近正品的产品出现。这或许就不光会让他们自己的官方翻机卖不出去，甚至于还会牵连到新品。这也就是为什么苹果在自己的独立维修商计划中，着重强调了对于第三方维修人员的培训，这无疑是将主动权掌握在自己手中的办法。换句话来说，只要维修权法案中依然存在关于产品原理图等“授人予渔”的条款，苹果等科技企业就势必会千方百计的阻扰其被通过。</p>
<h2 id="军队维修权">军队维修权</h2>
<h3 id="美国案例">美国案例</h3>
<ol type="1">
<li>海军的一名技术人员表示，曾经有一段时间他们能够排除故障并修复拥有的几乎所有东西。他们手头有备件（高故障项目），有完整的零件清单和故障排除图。现在，大多数新设备都签订了合同，军士无法维修，而是需要联系一名文职技术人员，他们必须上船解决问题。这意味着，当部署装备时，要付钱让某人飞行数千里进入战区，修理可能只需要简单组件更换的东西。多年来，这一直是军队中的一个问题。军队不得不付钱给承包商来帮助解决问题，因为甲方无法访问“专有”公司信息，甚至无法获得零配件。</li>
<li>在阿富汗服役的军人表示有很多设备即使很容易修理也不允许。他们付钱给现场服务代表，让他们留在阿富汗，这一切都赚的更多。有人看过账单。一个20美分的普通10级螺栓大约需要65美元，更换大约需要600美元。这并不夸张。洛克希德·马丁公司就是其中之一。洛克希德马丁公司已经把五角大楼变成了一个乞丐机构，任由国防承包商摆布，无法查明纳税人的钱是如何或在哪里花的。政府问责局 (GAO) 最近的一份报告 揭示 了 F-35 联合攻击战斗机的主要承包商洛克希德·马丁公司在该计划的整个生命周期内对管理和运营的控制程度，以及这如何阻碍了尝试削减成本和增加问责制，并阻碍了陷入困境的计划的整体有效性。</li>
<li>见过本可以在店里花 20 美元修理的设备被寄出，然后用 3 万美元完全更换。合同上说军人不能做，如果军人连系统维修都做不了，为什么军队要花那么多钱训练军士？美国实际上在国防合同上浪费了太多资金。他们把军队送回来的装备修好，又掉头又卖给军队，原价就像全新的一样。</li>
<li>军队机械师，在 Bradley 上的交流系统中遇到了这个问题。高温对人来说很糟糕，但对电子系统来说更糟糕，为这些车辆购买新零件损失了很多钱，而如果能够维护已经安装的空调系统，就可以避免这种情况。</li>
<li>在伊拉克(08-09)时，一个juniper防火墙关闭了，没有一个备份，他们不得不让承包商从各州飞到伊拉克进行更换。诊断问题用了10分钟，等待了3天，安装用了15分钟。在这3 天过程中失去了该地区捕食者无人机的电话、互联网、通讯和其他一些关键任务的反馈。</li>
<li>在军队军事情报部门工作6年的表示。使用的所有系统都有民用承包商来修复。英特尔的大多数产品只有几个人被允许使用。</li>
<li>在日本冲绳的一个维修单位工作，看着发动机被打包并运回美国的承包商进行维修，因为“合同是这么写的”。这个过程耗时数月。每送回一台发动机，海军陆战队就失去了在战场上练习他们有一天可能需要的技能的机会，在那里承包商的支持极其昂贵、不可靠或根本不存在。对于预计在最严峻和最恶劣的环境中作战的军队来说，如果不具备修理自己非常技术性的设备的经验、培训或工具，这意味着什么？会失去本地制造设备零件的能力，将失去在数小时而不是数天内将系统恢复战斗的能力。也失去了战斗损伤修复能力。</li>
</ol>
<h3 id="原因">原因</h3>
<p>有多种原因，从美国经济的历史性变化，到作为军事采购改革和军工基地整合的一部分所采用的法律和规则，但这些问题反映了民用领域发生的事情。 就武装部队而言，国防部从1940年代到1970年代对研发进行了大量投资，并且毫无疑问地拥有对其开发的设备进行维修的权利。从那以后的几年里，大部分研究和开发都转移到了商业领域。商业部门越来越多地开发也有军事用途的尖端技术，例如通信技术、软件、卫星发射和无人机。 为了加剧技术性军事系统的影响，1970 年代出现了一套有利于企业合并的新政治哲学，引发了整个民用部门的合并浪潮。国家安全领域的战略家的回应是，国防部需要成为更好的客户才能获得这种商业开发的技术。因此，国防部决定在与生产军事设备或提供服务以支持军队的商业公司谈判时，需要更加合作，不那么咄咄逼人。 与这种新范式相一致，政策制定者在1994年和1995年简化了《联邦采购条例》，将“商业物品”从大部分规则中豁免（并将商业物品的定义扩大到包括可以看到的物品）。作为专门的军品）。国会还鼓励联邦机构“在可行的最大范围内”购买商业物品。这些变化推动了商业采购的高利率，再加上国防工业的整合，促使国防部更多地使用商业技术和单一来源合同的谈判。 最终，权力动态在国防部和商业行业之间转移，迫使国防部接受以前可以避免的保证、合同或价格——这一切都归功于研发资金、法规和缺乏竞争的变化。 随着旧的军用车辆和系统被更复杂和涉及更多电子设备的设备所取代，维修权范式的影响只会变得更加重要和限制。已经很复杂的设备设计导致制造商是唯一的维修来源。</p>
<p>解决方案需要保护军方免受繁重的合同制度的影响。从根本上说，服务人员只想确保他们的装备准备好满足任务要求。虽然损坏的发电机或战术车辆可能看起来是小问题，但当需要修理战舰或战斗机时，其影响要大得多。当这些系统在通信或交通受限的地方发生故障时会发生什么？</p>
<h3 id="分析">分析</h3>
<p>这是 1980 年代和 1990 年代有关如何组织人员的深思熟虑的决定。该理论基本上是说复杂的系统需要专业化来构建和维护，而美国军方无法负担或招募可以同时进行操作、管理和故障排除的人员。换句话说，军事人员并不是十年专注于一件事的技术专家，而是像项目经理一样，从头5-6年开始在一个领域有深度，然后“拓宽”去填补管理层的力量。考虑到系统的规模和涉及的子系统数量 - 管理层以统一级别的形式增长，而技术人员层由于部队的结构方式而在承包商级别中增长。然而，合同力量的动机是保持合同（并继续）和与之相关的知识，因此最终建立了这种“除了承包商之外没有人可以触及这个”的要求。从功能上讲，可以看到这是一个自我实现的预言——军队没有重新招募或构建部队来拥有维护系统的能力，因为军队有一支合同部队来做到这一点。为了解决这个问题，必须慎重决定改变部队结构以培养更多的技术人员，不幸的是，这样的人不想接受减薪和生活方式的削减，所以无法填补队伍的空缺。 军方确实（至少在200X中确实如此）训练人们如何修理和排除故障。他们基本上让人们更适应做那种工作，并训练他们如何去做。几个接受过板级组件更换培训的人，但对于他们拥有的大多数设备，他们没有被授权进行维修，即使他们经过培训并配备了对大多数电路板进行故障排除和维修的能力（包括表面贴装）。</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Electronics_right_to_repair" target="_blank" rel="noopener">电子设备维修权</a></li>
<li><a href="https://www.ithome.com/0/553/371.htm" target="_blank" rel="noopener">微软反维修权法案</a></li>
<li><a href="https://www.zhihu.com/question/323101721" target="_blank" rel="noopener">苹果反维修权</a></li>
<li><a href="https://www.youtube.com/watch?v=KUimL241hNs" target="_blank" rel="noopener">美军维修权问题</a></li>
</ul>
]]></content>
      <categories>
        <category>repair</category>
      </categories>
      <tags>
        <tag>Electronics</tag>
      </tags>
  </entry>
  <entry>
    <title>consumerism</title>
    <url>/2021/07/17/consumerism/</url>
    <content><![CDATA[<h2 id="消费主义">消费主义</h2>
<p>消费主义（Consumerism）指相信持续及增加消费活动有助于经济的意识形态。消费主义为发达国家的经济引擎，使现代人有购买与获得商品的社会及经济上的信念及集体情绪。然而在社会科学领域中，不同领域因各别知识传统对消费主义有不同的定义与诠释。 <a id="more"></a></p>
<h3 id="文化研究观点">文化研究观点</h3>
<p>在工业资本主义时代以前，“消费”一词具有指涉过度购买行为的意义。英国学者雷蒙·威廉斯指出，消费（Consume）一词可追溯至14世纪，意同挥霍、用尽；而在16世纪出现的“消费者”（consumer）一词，也有相似的负面意思。然而到了19世纪中期，“消费者”已转化成中性词，用来指涉相对于“生产者”（producer）的抽象实体。到20世纪，这种抽象的用法进入日常的生活领域，成为一种日常用语，且具有支配性的意涵。在“消费者”一词出现以前，“顾客”（customer）在字面上，指涉相对于供给一方的需求者，而供需双方的互动是建立在实际的需求上的：“顾客”的需求是出于自我选择的，而供应商则是满足需求。但在消费主义兴起后，“消费者”取代了“顾客”，成为一种去个体化的抽象形体，其本质是大众，而大众的需求是由满足他们需求的一方所创造的。而在后现代主义中，消费主义也被视为是一种获得愉悦的活动形式。</p>
<h3 id="社会学观点">社会学观点</h3>
<p>消费主义是资本主义的主要问题之一。社会学从马克思开始就对消费主义采取批判观点。马克思主义中，消费主义之所以存在，是因为物与人的关系发生质变。资本主义出现以前，物品是劳动的直接成果，而物品的生产与交换通常在一地之内完成。这个时候，物品的价值是它的“实用价值”而非“交换价值”。但在资本主义社会中，物的价值是市场所赋予的，然而在市场的订价成为一物价值的标准，赋予物品一种仿佛是与生俱来的价值，但这样的价值也是人为建构的，而且是主观而具高度意识形态的。人为赋予物品价值的后果，造成一物的生产脉络被掩盖了，让消费者只看到一物“市场价格”的人为表象，却看不见制造的过程，忽略物品也是劳动的结果，直接或间接的造成马克思所主张的异化。</p>
<h2 id="消费主义的特点">消费主义的特点</h2>
<h3 id="市场论述主导">市场论述主导</h3>
<p>在消费主义社会中，市场是一个具有支配性的观念。在消费社会中，任何关系都可以被市场化，也就是以主观的交换价值来论断一人、一物或一件事情的价值。市场化同时也是一种暗喻，让市场主导的信念深植人心，认为市场是最有效率、最公平的分配方式。但这样的信念也是具高度意识形态的。</p>
<h3 id="过度制造">过度制造</h3>
<p>马克思主义中，消费主义是资本主义社会过度制造的必然产物。而资本主义要维持运作，就必须将工人转化为消费者，才能将大笔钱花在大量生产的货品上。消费主义之所以成为资本主义主要的意识形态之一，就是因为只有消费大量超过需求而生产的货品，才有可能维持资本主义的运作。波兰社会学家鲍曼也认为，在泰勒主义下的工人是“藏于生产者中的消费者”，被期待在消费中获得个人的自由。</p>
<h3 id="个人化">个人化</h3>
<p>个人化首先意指的是现代社会中集体意识渐渐消失的倾向。现代社会不如传统社会强调人际关系，而是以个人为主。个体之间是疏离的，而组成大众的则是互不相干的个人。在消费社会中，更被强调的是个人主义，也就是个人作为一个具有自主性的能动者，依工具理性达成自己的目标，例如消费行为代表个人表达的欲望。这为经济提供了动力，并带来个人的满足。然而在新自由主义下的消费社会中，如同美国社会学家大卫·理斯曼所言，作为消费者的人们支持政府去管制化，但同时身为工作者，也可能因为去管制化而面临问题（例如失业），而集体防御没有太大意义，工会力量也大幅缩减。换言之，这些消费者组成了“孤单的群众”（the lonely crowd），无法组织起来保护自己的权益。个人化的另一个意义在于，现代品牌营销将所有产品包装成定制的，宣称产品对个别消费者而言独一无二，但事实上大众产品之间差异不大。</p>
<h3 id="商品化">商品化</h3>
<p>社会文化也为商品所改变，商品成为了文化的主体，人的重要性退居其次；量产商品背后的意义被掏空了，而广告或大众传播媒介上的节目内容塑造了商品的形象，赋予商品新的意义，甚至是具有人性的特质，让产品神秘化，转而为崇拜对象，而且可以借由购买而得到物品上的特质。这就是马克思论述中的商品拜物教。另外，个人也用商品人性化的特质，来建构自己的个性。</p>
<h3 id="美学化与符号消费">美学化与符号消费</h3>
<p>商品的意义被广告重新塑造，一个商品可能是神秘或性感的，具有人类的特质，而个人可以透过消费购买这些特质。后现代主义学者尚·布希亚称之为“物”的体系，描述物品被大量生产后，因为被赋予各种不同的意义与精神，商品仿佛有自己的生命一般，自行衍生而成为体系。而布希亚也认为对物品的消费是一种狂欢与释放，具有游戏的特质，可以借由购买符号而获得满足与愉悦，以此逃离日常例行工作的机制。</p>
<h3 id="去稳定化">去稳定化</h3>
<p>消费主义社会中的劳资关系不稳固，个人有如商品一样，可以被购得或弃置，鲍曼认为这是消费社会的身份认同。在无法确保有稳定收入的状况下，以往的延迟享受变成了及时享乐，如同鲍曼所言“消费主义是信用卡的社会，而不是存折的社会。”与个人化的因素一并考量下，个人越来越难在紧密的人际关系中，以及在工作当中找到生活的意义。在这样的情况下，通过购物获得的满足可暂时填补生活的空虚。</p>
<h3 id="治疗论述">治疗论述</h3>
<p>美国文化历史学者李尔斯指出，治疗论述是一种“你不够完美”的想法，而这样的想法在西方是由基督新教伦理所产生的观念，强调禁欲与刻苦工作。在宗教世俗化之后仍继续留在西方文化中，仍是日常生活的道德原则。而治疗论述每隔一段时间就会从这样的观念移转到休闲、花费与个人满足上，以此作为自我放纵的合理化借口；只有认为自己不够完美，才有取得更多物质，而通往美好生活的想像发生，但也因此造就人生的无奈感。然而商品带给人的满足在购买后很快会消失，特别是在满足情绪的需求上，商品的效用是不持久的，因而只有透过不断消费，才能带来满足。</p>
<h2 id="消费主义的问题">消费主义的问题</h2>
<p>消费主义可能会造成公民社会的消逝。因为消费主义的基本意识形态是市场关系，也就是在所有的人际关系中，被市场意识渗透，而市场逻辑成为指导原则。例如，在新自由主义经济政策下，大规模私有化让许多财货都落入私人企业手中，而一般人要透过消费才可以获得这些产品或服务。但公民的概念中，有许多权利，例如医保制度，是人人生而有之的。换句话说，不论贫穷或富有都享有同等待遇。然而在新自由主义的消费导向社会中，这些公民的基本权利变成需要透过消费所获得，一般人必须要是积极的消费者，才能是好的公民。如此一来，便排除了经济上弱势的中下阶层民众。此外，消费社会中的企业可能透过各种手段，例如选举资助、政治献金，而对政治造成影响，例如形成压力团体，迫使立法机关做出对企业有利的立法，但却不一定符合人民的利益。</p>
<h3 id="消费主义在21世纪的发展">消费主义在21世纪的发展</h3>
<p>在21世纪的全球化经济中，消费主义已成为文化的重要组成部分。对这一现象的批评者不仅批评它在环境上是可持续的，而且还批评了消费主义在文化方面的传播。但是，有几位学者撰写了有关消费文化与环境的交集的文章。经济学家古斯塔夫·斯佩思和内奥米·克莱因[76]和消费者文化历史学家加里·克罗斯讨论了消费主义意识形态在工作中对环境的影响。莱斯利·斯克莱尔（Leslie Sklair）在他的作品中通过消费主义的文化意识形态概念提出了批评。他说，首先，资本主义在1950年代进入了质的新的全球化阶段。随着电子革命的进行，资本主义工厂的生产力，原材料的提取和加工系统，产品设计，商品和服务的营销以及分销开始发生重大变化。 其次，构成世界各地大众媒体的技术和社会关系使新的消费主义生活方式很容易成为这些媒体的主导主题，从而及时成为了传播文化的极其有效的手段，全球消费主义意识形态。 截止到今天，人们在媒体甚至日常生活中都暴露于大众消费主义和产品定位。信息，娱乐和产品促销之间的界限已经模糊，因此人们被重新设定为消费主义行为。购物中心是人们明显地处于欢迎和鼓励消费的环境中的典型代表。高斯说，购物中心的设计师“力求为购物中心的存在提出另一种理由，通过空间的配置来操纵购物者的行为，并有意识地设计出一种象征性的景观，从而激发购物者的联想情绪和性格。” 关于日常生活中消费主义的普遍性，历史学家加里·克罗斯（Gary Cross）说：“服装，旅行和娱乐的不断变化为几乎每个人提供了机会，无论他们的种族，年龄，性别或阶级，都有找到自己的利基的机会。”</p>
<p>可以说，消费主义文化意识形态的成功可以在全世界被证明。急于在商场购买产品并最终用信用卡消费的人可能会根深蒂固地陷入资本主义全球化的金融体系。</p>
]]></content>
      <categories>
        <category>repair</category>
      </categories>
      <tags>
        <tag>Marxismus</tag>
      </tags>
  </entry>
  <entry>
    <title>PNT</title>
    <url>/2020/08/06/PNT/</url>
    <content><![CDATA[<h2 id="导航类别">导航类别</h2>
<ul>
<li>天文导航</li>
<li>地磁导航</li>
<li>无线电导航</li>
<li>惯性导航</li>
<li>量子导航</li>
<li>图像导航 <a id="more"></a></li>
</ul>
<h3 id="卫星导航定位">卫星导航定位</h3>
<p><strong>原理</strong>：三球定位。通过向在轨卫星发射电磁波脉冲并检测信号到达接收机的时间延迟来实现定位。</p>
<p><strong>优点</strong>：全天候、高精度、小误差。</p>
<p><strong>缺点</strong>：存在可靠性与精度问题，时钟误差、系统误差、偶然误差等；导航系统空间段易受到欺骗和干扰，如拒绝服务攻击（包括GPS欺骗）和信号干扰。GPS欺骗者会假冒GPS卫星的信号发送虚假数据，从而使终端设备无法获得准确的位置或根本无法获得任何位置信息。导航系统地面段面临针对地面运控系统的攻击。用户段面临针对用户终端接收机的电磁干扰。在水下、隧道、掩体、室内等环境中，卫星定位信号无法穿透水、建筑物和其他实体，无法进行卫星导航。</p>
<p><strong>安全对策</strong>：空间段，采取包括星座设计、冗余策略和卫星加固等方式应对安全威胁。地面段，将地面运行控制系统建设在境内可以进行安全防范的区域，同时建设遍布全球的监测和评估系统，掌握系统实时运行状态，提高系统的安全性。终端层面，在接收机的电路上通过加长接收机预检测积分时间，利用惯性导航实现组合导航，或者利用自适应滤波手段对干扰信号进行规避等方式可以对抗干扰，也可以在接收机的天线中通过加入干扰对消器、优化天线的极化设计、使用自适应调零天线、波束控制和波束形成天线来对抗干扰。</p>
<h3 id="惯性导航">惯性导航</h3>
<p>利用惯性敏感器、基准方向及最初的位置信息来确定运载体的方位、位置和速度，实现自主式航位推算导航。其不依靠接收卫星信号，属于无源定位系统。</p>
<p><strong>缺点</strong>：陀螺仪的漂移误差、平台初始误差、元件安装误差、冲击和振动引起的运动误差等。</p>
<h3 id="qps">QPS</h3>
<p>与卫星导航采用的电磁波信号不同，QPS的测距信号是具有量子特性的脉冲信号，这种信号是由没有电荷和质量的光子组成，光量子具有量子纠缠和量子压缩特性。目前主要有：星基量子导航系统，将量子信息与卫星定位技术进行结合。这种基于量子力学理论建立的量子导航定位系统与传统卫星导航类似，需要发射信号来实现用户的四维坐标的定位，所不同的是 QPS 采用的是相干关联的量子信号，仍属于有源定位系统。另一种为量子惯性导航系统。基于量子惯性器件实现导航的量子定位系统，与传统惯性导航系统类似，靠自身惯性器件实现姿态调整与定位，不需要从在轨卫星实时接收信号进行测距和授时，属于无源定位系统，一般主要由三维原子陀螺仪、三维原子加速度计、原子钟和信号采集及处理单元四部分构成。三是脉冲式量子定位；四是利用地磁场的亚原子效应进行定位，即“量子罗盘”。</p>
<p><strong>优点</strong>：更加精确的测量精度。保密通信安全性能更强</p>
<p><strong>缺点</strong>：理想光量子纠缠源的制备比较困难。无源的设备小型化困难。技术不成熟。</p>
<h3 id="图像导航技术imagenav">图像导航技术（ImageNav）</h3>
<p>利用弹上传感器对地形成像，将飞行路径与存储的地形数据进行对比，可以达到3米的圆概率误差水平。</p>
<h3 id="地磁导航">地磁导航</h3>
<p>地磁场是地球的固有资源，为航空、航天、航海提供了天然的坐标系。在地球近地空间内任意一点的地磁矢量都不同于其它地点的矢量，而且与该地点的经纬度存在一一对应的关系。因此，理论上只要确定该点的地磁场矢量即可实现全球导航。近年来，地磁导航因其隐蔽性能好、效费比高、即开即用，误差不随时间积累的优势而被广泛应用和快速发展。早在2003年8月，美国国防部军事关键技术列表中提到，他们所研制的纯地磁导航系统在地面和空中的定位精度优于30米（CEP）。俄罗斯的新型SS-19导弹采用地磁场等值线匹配制导方式，导弹进入大气层后，不是按抛物线飞行，而是在稠密大气层内沿地磁等高线飞行，使美国导弹防御系统无法准确预测来袭导弹的飞行弹道轨迹，大大增强了导弹的突防能力。美国生产的波音飞机上配备有地磁匹配制导系统，供飞机起飞降落时使用。目前，该技术已经在高空长航时无人机上得到验证，并和GPS组合使用。在GPS完好时，将磁强计同时用于定姿和定位，以提高惯导/GPS组合导航系统的精度；在GPS失效时，利用磁场匹配辅助惯性导航，减少惯导系统输出误差。</p>
<p>另外还有导引头成本转变项目（SECTR）、随机信号导航项目（NAVSOP）等等。</p>
]]></content>
      <tags>
        <tag>satellite</tag>
        <tag>navigation</tag>
      </tags>
  </entry>
  <entry>
    <title>local-first</title>
    <url>/2020/08/03/local-first/</url>
    <content><![CDATA[<h2 id="现有数据存储和共享模型">现有数据存储和共享模型</h2>
<h3 id="多设备文件共享与传输">多设备文件共享与传输</h3>
<ul>
<li>使用分布式文件系统，如NAS服务器，NFS，FTP或rsync;</li>
<li>使用Dropbox，Google Drive或OneDrive之类的云文件存储服务；</li>
<li>使用版本控制系统（如Git）；</li>
<li>USB摆渡；</li>
<li>Email、IM等； <a id="more"></a></li>
</ul>
<p>Web应用程序中的数据存储于服务器。服务器通常使用大型数据库，将数以亿万的用户数据全部混合到一个巨大的集合。用户在任何设备上打开文档时看到的都是最新版本。如Microsoft Office这样的传统上仅限本地使用的软件也正在向云服务过渡，使用Office 365取代了本地安装的Office。</p>
<p>像GitHub这样的存储库托管服务可实现围绕Git存储库的协作，从多个设备访问数据以及提供备份和存档位置。</p>
<h3 id="构建应用程序的基础架构">构建应用程序的基础架构</h3>
<h4 id="web应用程序瘦客户端">Web应用程序（瘦客户端）</h4>
<p>最纯形式的Web应用程序通常是在服务器上运行的Rails，Django，PHP或Node.js程序，将其数据存储在SQL或NoSQL数据库中，并通过HTTPS提供网页。所有数据都在服务器上，Web浏览器是瘦客户端。</p>
<p>这种体系结构优点是只需访问URL，所有数据都由部署应用程序的人员和DevOps人员存储在一个地方。用户可以从所有设备访问该应用程序，轻松进行协作。</p>
<p>为使Web浏览器更好地脱机工作，开发人员进行了很多努力如缓存，localStorage，service-workers和Progressive Web Apps等，但Web应用程序的体系结构从根本上仍然以服务器为中心。</p>
<h4 id="带有本地存储的移动应用胖客户端">带有本地存储的移动应用（胖客户端）</h4>
<p>iOS和Android应用程序是本地安装的软件，在运行该应用程序之前已下载并安装了整个应用程序二进制文件。但是大量的应用程序还是瘦客户端，类似于网络应用程序，它们需要服务器才能运行（如微信、支付宝等）。</p>
<p>还有一类移动应用程序，其首先使用诸如SQLite，Core Data或仅普通文件之类的持久层将数据存储在本地设备上。其中一些（例如Clue或Things）以没有任何服务器的单用户应用程序开始，之后逐渐添加到云后端，在设备之间同步或与其他用户共享数据。</p>
<h4 id="后端即服务firebasecloudkit">后端即服务：Firebase，CloudKit</h4>
<p>Firebase本质上是一个本地设备数据库，结合了云数据库服务和两者之间的数据同步。Firebase允许跨多个设备共享数据，并且支持脱机使用。</p>
<h2 id="crdt">CRDT</h2>
<p>除了operational transformation（把编辑操作转换为patch，然后 (可能在服务器) apply或回滚），另外一个比较有名的实时协作编辑模型为CRDT（Conflict-free Replicated Data Type），也称为a passive synchronisation，即免冲突的可复制的数据类型，诞生自2011年的学术计算机科学研究中。这种数据类型可用于数据跨网络复制并且自动解决冲突达到一致，非常适合使用AP架构（可用性、分区容错性）的系统在各个partition之间复制数据时使用；具体实现上可以分为State-based的CvRDT、Operation-based的CmRDT、Delta-based、Pure operation-based等。</p>
<p>尽管在设计CRDT的算法和验证其理论正确性方面的学术研究取得了长足的进步，但到目前为止，这些技术在工业上的应用相对较少。此外，大多数工业CRDT都用于以服务器为中心的计算中，但是该技术在客户端应用程序中也具有巨大潜力。</p>
]]></content>
      <categories>
        <category>cloud</category>
      </categories>
      <tags>
        <tag>architecture</tag>
      </tags>
  </entry>
  <entry>
    <title>root-z17</title>
    <url>/2020/06/09/root-z17/</url>
    <content><![CDATA[<h2 id="required-files">required files</h2>
<ol type="1">
<li>twrp Nubia Z17</li>
<li>Magisk</li>
<li>Platform tools/adb Fastboot tools</li>
<li>No verity opt Encrypt <a id="more"></a></li>
</ol>
<h2 id="install-twrp">install twrp</h2>
<ol type="1">
<li>Setup <strong>Platform tools</strong></li>
<li>Extract <strong>recovery.img</strong> file Inside the adb tools Folder.</li>
<li>Switch off <strong>Phone</strong> and together Press Volume Down and Power button it Will boot it in fastboot Mod.</li>
<li>Then Connect Phone to PC using the usb cable.</li>
<li>Now open CMD in the <strong>Platform Folder</strong> and type below Code.</li>
</ol>
<p>Check Device by Sending below Command:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">fastboot devices</span><br></pre></td></tr></table></figure>
<p>unlock bootloader by Sending below Command: <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">fastboot oem nubia_unlock NUBIA_NX563J</span><br></pre></td></tr></table></figure> flash Recovery by Sending below Command: <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">fastboot flash recovery recovery.img</span><br></pre></td></tr></table></figure></p>
<h2 id="root-z17">root z17</h2>
<ol type="1">
<li>Download</a> Magisk.zip</strong> File From the above and Move it to Device Storage.</li>
<li>Now Switch off Phone and together Press Volume Up and Power button it Will <strong>boot your Phone in twrp</strong>.</li>
<li>In the <a href="https://unofficialtwrp.com/tag/twrp/" target="_blank" rel="noopener">twrp</a> Click on backup Button Select Require Partition and Swipe Slider to Create a <strong>nandroid backup</strong>.</li>
<li>Click on Install Button and Locate Downloaded <strong>Magisk.zip</strong> File and Then Swipe Slider to Install it.</li>
</ol>
<h3 id="next">next</h3>
<ol type="1">
<li>again Click on Install and then Locate <strong>No verity opt encrypt.zip and Swipe Slider</strong> to Install it.</li>
<li>Done/ then Reboot System Now. Your Phone <strong>Successfully <a href="https://unofficialtwrp.com/tag/root/" target="_blank" rel="noopener">Rooted</a></strong>.</li>
</ol>
<h2 id="experience">experience</h2>
<p>Link 1 below offers the active <a href="https://mega.nz/#!NQhiEIhQ!QCXyMCLMzzpoLRiV38kT2wI59jy3Dsy9ufYVS2P3A3Q" target="_blank" rel="noopener">image</a> files. If some images files does not work, we can try more image files. It's better to install supersu tools. If fastboot command does not show any device, it's probably the driver is not install properly, and it can be solved by update the related driver from internet automatically in the device manager.</p>
<h2 id="reference">reference</h2>
<p><a href="https://forum.xda-developers.com/nubia-z17/how-to/how-to-unlock-bootloader-flash-twrp-t3636861" target="_blank" rel="noopener">1. unlock-bootloader-flash-twrp</a></p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>root</tag>
      </tags>
  </entry>
  <entry>
    <title>Wi-Fi-versions</title>
    <url>/2020/05/29/Wi-Fi-versions/</url>
    <content><![CDATA[<h2 id="wi-fi-4802.11n">Wi-Fi 4(802.11n)</h2>
<p>物理层规范HT PHY，信道宽度20MHz、40MHz，2.4GHz和5GHz频段，最高4条空间流，单流调制编码方案(MCS)支持0~7，最大副载波调制64-QAM，最高速率600 Mbps（4*4空间流），认证计划为“Wi-Fi CERTIFIED n”。 <a id="more"></a> 802.11n增加了对于MIMO的标准，2.4GHz和5GHz都可自由选择20MHz或40MHz带宽，使用多个天线来允许更高的数据传输率，但一些设备只允许在5GHz下使用40MHz带宽，如果用一台只支持2.4GHz的150Mbps路由器，则最多只能使用72Mbps，即20MHz带宽下的最快速度。</p>
<p>以802.11AC 1T1R MCS9 HT80 带宽Short GI为例计算网络连接速率，可以知道: RateHT80=(234MHz∗8bit∗5/6)/(3.2us+0.4us)=433.33Mbps</p>
<p>2*2空间流（（并行的空间通道就叫做空间流，一般情况下空间流数和天线数量对应））最高支持300Mbps（40MHz）速率。在相同位置的情况下，2x2 Wi-Fi比1x1 Wi-Fi的吞吐量提升一倍，同时时延降低一倍（2x2 Wi-Fi有3%的概率会超过40毫秒时延，而1x1 Wi-Fi有12%的概率会超过40毫秒时延）；而在保持吞吐量相同的条件下，2x2 Wi-Fi可以将传输距离变的更远，很多时候可以拉到两倍以上的距离。</p>
<p>然而，从原来1根天线变成2根天线，设计的复杂度会增加。如何解决问题呢？高通拥有Modem、SoC，又有Wi-Fi连接芯片的优势，可以集中技术去共享天线，这样，并不需要增加1根物理天线，就可以得到2根天线的使用效果。这对于手机厂商的设计复杂度来说是非常大的改善。当LTE天线和Wi-Fi天线越来越多时，如何节省天线、如何摆放天线的位置都极其重要。高通将Wi-Fi与LTE共享一根天线，这样一来，IP设计也不需要做太大的改动。高通骁龙835和660均支持LTE和Wi-Fi之间智能天线共享。</p>
<h2 id="wi-fi-5802.11ac">Wi-Fi 5(802.11ac)</h2>
<p>2014年推出802.11ac Wave1，2016年推出802.11ac Wave2。物理层规范VHT PHY，信道宽度20MHz、40MHz、80MHz、80+ 80MHz、160MHz，5GHz频段，最高8条空间流，单流MCS0~9，单流最大速率866Mbps，最大副载波调制256-QAM，最高速率6.9 Gbit/s，认证计划为“Wi-Fi CERTIFIED ac”。</p>
<p>从4×4 MU-MIMO提升到8×8 MU-MIMO，就是以前每个资料封包每次只能组合4个终端，现在可以组合8个了。这当然不是说MU-MIMO网路中只有4个或8个终端，而是每一画格(frame)中最多容纳4-8个终端，整个网路的容量达到上百个是没有问题的，这就明显提高了效率。</p>
<p>在中国，自2012年工业和信息化部开放5150～5350MHz（36～64）频谱在室内环境下的使用权限后，国内在5GHz频段互不干扰的信道（20MHz）从原来的5735M～5835MHz（149～165）的5个增加至13个，但只有1个连续的160MHz频宽信道（3个80MHz频宽信道）。可以使用的信道有36,40, 44, 48, 52, 56, 60, 64, 149,153, 157, 161, 165，而每个信道频宽为20Mhz。如果信道为149，当要用80Mhz时，则153,157,161都要被占用了。支持80M频宽的有信道36/40/44/48，52/56/60/64（这四个是DFS），149/153/157/161三组，每一组设置哪一个信道都一样，注意165只支持20M频宽不支持40M/80M频宽。支持160M频宽连续的信道只有36/40/44/48/52/56/60/64一组，这里面包含DFS信道，DFS信道有时会导致信道更改 选择不连续160M信道（即80M+80M）想信道稳定就选择不包含DFS的信道36/40/44/48+149/153/157/161。</p>
<p>Intel ac9560支持2*2 Wi-Fi 5的标准，最大速率1733Mbps。</p>
<h3 id="新技术">新技术</h3>
<ul>
<li>强制支持至80MHz带宽(相对于802.11n支持至40MHz带宽),而160MHz带宽为可选择是否支持</li>
<li>支持8个MIMO空间流（802.11n只能支持4个）</li>
<li>Multi-user MIMO（MU-MIMO），从802.11ac Wave2开始提供支持（下行DL）。</li>
</ul>
<p>传统的SU-MIMO模式下，在同一个时间点内，路由器只能传输给一个接收设备的数据，如果有3个设备在观看4K高码流的电影，这时就会造成某台设备播放不流畅。</p>
<p>而MU-MIMO模式，在同一个时间点内，路由器可以同时跟3个设备传输数据，这时大家播放都变流畅了。但mu-mimo不是路由器用一根天线跟一个设备传输，三根天线就同时跟三个设备传输。而是利用波束成形技术，同时发出不同的无线波束，支持mu-mimo的接收设备只会接收属于自己的波束。从本质上来说，MU-MIMO 的工作原理就是利用波束塑型技术同时向空间上不同的位置发送流量。尽管 Wave 2 MU-MIMO 并没有改变每个 WLAN 连接中的最大可能物理层（PHY）速率，但它通过多客户端共享相同接入点的环境，提高了每个接入点所能支持的汇聚吞吐量。波束塑型可以将能量聚焦于某个客户端上，波瓣的显示的是波束塑型通过聚焦方式提高能量的区域，因此其信噪比（SNR）和数据速率也会提高。波束塑型可以提高无线网络在中等距离上的性能。在较短的距离上，信号功率已经足够高，因此其信噪比完全可以支持最大数据速率。IEEE 802.11ac Wave 2 的定义规定可以生成最多 4 个此类波束，同时支持最多 4 个的MU-MIMO 用户。客户端之间的波束塑型进程可以描述为，接入点向笔记本电脑之类的客户端发送 IP 数据包等更高级别的数据。该过程首先要通过一个校准进程来测量两台设备之间无线电信道的信号强度和相位。尽管通常情况下波束塑型可能是外显或不外显的，具体情况取决于是否使用了特殊的测量帧，但在波束塑型的 802.11ac 标准格式下，需要使用信道测量帧，因此它只能是外显的。波束塑型进程中的这个信道校准步骤也被称为回声测量，可以定期在为 MU-MIMO 选定的部分或所有客户端上执行，但回声测量的频繁程度视具体的实施而定。</p>
<p>MU-MIMO一定要强调“兼容设备”，接收设备端不支持就没用。更重要的是，接入的所有终端都兼容MU-MIMO的情况下，MU-MIMO机制才会生效！设备是否支持MU-MIMO的比例十分影响MU-MIMO的发挥程度。譬如说路由器连接上20部设备，如果只有其中三四部设备支持MU-MIMO，那MU-MIMO带来的效果几乎微乎其微。另外，MU-MIMO只有在多个支持MU-MIMO设备同时传输的时候发挥作用，对单设备传输速率极限并没有任何影响。</p>
<h2 id="wi-fi-6802.11ax">Wi-Fi 6(802.11ax)</h2>
<p>信道宽度20MHz、40MHz、80MHz、80+ 80MHz、160MHz，2.4GHz和5GHz频段，最高8条空间流，最大副载波调制1024-QAM，最高速率9.6 Gbit/s，认证计划为“Wi-Fi CERTIFIED 6”。</p>
<h2 id="wi-fi-6e">Wi-Fi 6E</h2>
<p>Wi-Fi 6E是把Wi-Fi 6的协议从现在的双频2.4GHz、5GHz拓展至6GHz频段，E代表Extended。Wi-Fi 6E与Wi-Fi 6的差异主要是在原有的频段上加入全新的6GHz频段(5925-7125MHz，共1.2GHz频宽)以容纳更多的通道数。2020年2月，高通基于Wi-Fi 6E的架构还进行了端对端的OTA展示。</p>
<h2 id="reference">reference</h2>
<p><a href="https://lwz322.github.io/2019/09/09/WiFi.html" target="_blank" rel="noopener">从WiFi速率到无线通信</a></p>
]]></content>
      <categories>
        <category>equipment</category>
      </categories>
      <tags>
        <tag>Wi-Fi</tag>
        <tag>router</tag>
      </tags>
  </entry>
  <entry>
    <title>used laptops</title>
    <url>/2020/05/26/used-laptops/</url>
    <content><![CDATA[<h2 id="tcl-l2010">TCL L2010</h2>
<p>处理器和主芯片 Intel Mobile Celeron <a id="more"></a> 系统内存 内置128MB SDRAM（最大可扩充至384MB） PC133 SDRAM 存储系统 2.5″ 最高9.5mm high Hard Disk Drive ATA 100 Capacity Hard Disk Drive 外置24XCD-ROM/8X DVD-ROM/CD-RW（选购） USB外接式3.5' 1.44 MB软驱（选购） 音频系统 内建全双工3D立体音效设备 音量调节旋钮 显示装置及图形能力 12.1'XGA TFT LCD, 支持分辨率1024x768高分辨率 SiS 630ST内建视讯影像处理功能 AGP 4X 通信与网络接口 56Kbps 高速调制解调器 内建Ethernet 10/100网卡 输入/输出口 PCMCIA插槽TYPEIIX1 两个USB连接口 一个RJ-11数据端口 一个RJ-45局域网端口 一个15针CRT口,可外接显示器 电源DC-in IEEE1394高速数据传输端口 Audio插口（Spesker out/Mic-in) ROM Drive port (IDE I/F) 键盘和触摸屏设备 支持WINDOWS功能键键盘 五个快捷功能键,一个邮件接收件 电源系统 AC 100-240V自适应 电源管理APM1.2/ACPI1.0 体积与重量 269 * 218 * 24.4mm 1.8kg</p>
<h2 id="acer-4520g">Acer 4520G?</h2>
<p>linux installed; AMD Athlon 64 X2 TL-58;</p>
<h2 id="asus-m51kr">asus m51kr</h2>
<p>used for short period; AMD Turion 64 X2 Mobile Technology TL-56; 2048 MB RAM; hd3470; DAC Type:Internal DAC(400mhz)</p>
<h2 id="asus-n75yi267sl-sl">asus N75YI267SL-SL</h2>
<p>i7 2670QM; 17.3";</p>
<h2 id="lenovo-小新潮7000-13.3">lenovo 小新潮7000-13.3</h2>
<p>1.2kg;</p>
<h2 id="thinkpad-x1e">thinkpad x1e</h2>
<p>tb3;</p>
]]></content>
      <categories>
        <category>equipment</category>
      </categories>
      <tags>
        <tag>laptop</tag>
        <tag>record</tag>
      </tags>
  </entry>
  <entry>
    <title>mobile-battery</title>
    <url>/2020/04/20/mobile-battery/</url>
    <content><![CDATA[<h2 id="download-android-sdk-platform-tools">Download android sdk platform tools</h2>
<p>也可以只使用命令行adb工具。</p>
<h2 id="debugger">Debugger</h2>
<p>手机USB连接电脑，查看状态： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adb shell</span><br><span class="line">cat /sys/class/power_supply/bms/uevent</span><br></pre></td></tr></table></figure></p>
<p>其中主要有充电完全设计容量为3200毫安和当前可充电完整容量2005毫安。 <a id="more"></a> <img src="/images/battery.png" alt="battery" /></p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>battery</tag>
      </tags>
  </entry>
  <entry>
    <title>jetbrains-installation</title>
    <url>/2020/04/20/jetbrains-installation/</url>
    <content><![CDATA[<h2 id="register">Register</h2>
<p>忽略注册窗口，先选择试用30天进入。然后配置代理使用自动模式，再检查测试注册网址：http://account.jetbrains.com。弹出证书认证窗口，记录pwd，确认添加。</p>
<h2 id="certification">Certification</h2>
<p>Windows 10中找出系统盘安装的软件配置目录下的cacerts文件，打开certmgr.msc，导入受信任的根证书机构，输入pwd。</p>
<h2 id="activate">Activate</h2>
<p>选择jb account，输入登录信息。</p>
]]></content>
      <categories>
        <category>software</category>
        <category>jetbrains</category>
      </categories>
      <tags>
        <tag>jetbrains</tag>
      </tags>
  </entry>
  <entry>
    <title>virtual-memory-and-cpu-paging</title>
    <url>/2020/03/24/virtual-memory-and-cpu-paging/</url>
    <content><![CDATA[<h2 id="虚拟内存是什么">虚拟内存是什么？</h2>
<p>虚拟内存（virtual memory，VM）是一种内存管理技术。它是操作系统提供的一种对主存的抽象。</p>
<h2 id="虚拟内存可以做什么">虚拟内存可以做什么？</h2>
<p>它为每个进程提供了一个大的、一致的和私有的地址空间。 <a id="more"></a></p>
<ol type="1">
<li>它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了主存。</li>
<li>它为每个进程提供了一致的地址空间，从而简化了内存管理。从程序员的观点看，它为程序员提供了无限线性内存的视图从而不必担心实际有限的内存及其管理过程。VM简化了链接、加载、代码和数据共享及应用程序的内存分配。</li>
</ol>
<ul>
<li><strong>位置无关代码</strong> 数据/代码可以位于物理内存中的任何位置，这不会以任何方式影响其功能。</li>
<li><strong>代码共享</strong> 一般而言，每个进程都有自己的私有代码、数据、堆及栈区域，不和其他进程共享。这种情况下，操作系统创建页表，将相应的虚拟页映射到不连续的物理页面。不过有时还是要进程共享代码和数据。在这种情况下，只需要代码的一个副本（例如典型的python库或是c中的printf等）。不同的虚拟地址可以映射到物理内存中的相同位置，这消除了在内存中多个副本。</li>
</ul>
<ol start="3" type="1">
<li>它保护了每个进程的地址空间不被其他进程破坏。防止有意或无意地尝试访问某些其他进程（或OS）内存。</li>
<li>文件可以直接映射到进程的内存空间，以便快速访问。只有在需要数据时才会发生I/O。</li>
<li>存在高级垃圾收集算法，其使用关于对页面的读取和写入访问的信息（虚拟存储器硬件的特征）以使其更有效。</li>
</ol>
<h2 id="分页">分页</h2>
<p>分段允许进程的物理地址空间是非连续的。分页是提供这种优势的另一种内存管理方案。然而，分页避免了外部碎片和紧缩，而分段不可以。不仅如此，分页还避免了将不同大小的内存块匹配到交换空间的问题。在只分段的情况下，CPU认为进程需要的地址等于物理地址，而进程需要的地址是由编译器编译出来的，他本身是连续的，所以物理地址也必须要连续才可以。</p>
<p>在保护模式中段寄存器中的内容已经是选择子了 ，但选择子最终就是为了找到段基址，其内存访问的核心仍是"段基址：段内偏移地址"，这2个地址相加后之后得到的是绝对地址，此地址在分段机制下被CPU认为是物理地址。</p>
<p>但是如果CPU打开了分页机制，段部件输出的线性地址称之为虚拟地址。此虚拟地址对应的物理地址需要在页表中查找，这项工作是由页部件完成的。</p>
<p>分页通过 CPU 的 MMU完成，每个处理器都有自己的页表集合。MMU 通过当前的分页表完成虚拟地址到物理地址的转换。 <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cucGVkaXkuY29tL2tzc2QvcGVkaXkxMi8xMzUyNzQvOTY4NzAzLzU3OTEzLnBuZw?x-oss-process=image/format,png" alt="paging" /> 在 x86 下 MMU 通过两级分页表（也可以开启三级）完成地址转换，这两级分别是页目录(Page Directory)和页表(Page Table)。Intel x86 CPU将页表目录的指针存储在特殊寄存器CR3中. 该寄存器指向一个包含1024个32位值的数组, 称为页目录. 每个数组元素称为页目录项, 它指定了页表在物理内存中的基地址, 还通过状态位指示该页表当前是否存在于内存中. 从页表中可以获得实际的物理地址。 <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cucGVkaXkuY29tL2tzc2QvcGVkaXkxMi8xMzUyNzQvOTY4NzAzLzU3OTE0LnBuZw?x-oss-process=image/format,png" alt="mmu" /> 下面我们来看下虚拟地址的组成: <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cucGVkaXkuY29tL2tzc2QvcGVkaXkxMi8xMzUyNzQvOTY4NzAzLzU3OTE1LnBuZw?x-oss-process=image/format,png" alt="vmcomp" /> 由图可知, 虚拟地址的前10位用来定位页目录项, 中间10位用来定位页表项, 最后12位得到具体物理地址的偏移.</p>
<p>到了这里, 我们来总结下具体的步骤: 1. CPU查询CR3寄存器以找到页表目录的基地址 2. 操作系统根据所请求的虚拟地址的前10位(如图3), 来定位页目录项, 从而在内存中找到相应的页表. 3. 页表根据中间的10位定位该页相应的物理内存首地址 4. 根据虚拟地址的后12位得到具体的物理地址相对于首地址的偏移量. 5. 最后得到的物理地址即包含我们要请求的数据</p>
<h3 id="页大小">页大小</h3>
<p>页大小是由硬件来决定的，通常由处理器的结构决定。可用的页面大小取决于指令集架构，处理器类型和操作（寻址）模式。某些指令集体系结构可以支持多种页面大小。操作系统从架构支持的大小中选择一个或多个大小。</p>
<table>
<thead>
<tr class="header">
<th>架构</th>
<th>页面大小</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>arm64</td>
<td>4K，2M和1G（如果使用CONFIG_ARM64_64K_PAGES = y构建自己的内核，则为64K和512M）</td>
</tr>
<tr class="even">
<td>I386</td>
<td>4K和4M（PAE模式下2M）</td>
</tr>
<tr class="odd">
<td>IA64</td>
<td>4K，8K，64K，256K，1M，4M，16M，256M</td>
</tr>
<tr class="even">
<td>PPC64</td>
<td>4K和16M</td>
</tr>
</tbody>
</table>
<p>常见页大小为4KB，如Linux和Windows在用户空间都使用4KB的页。0-4095B处于第0页，4096-8191是第1页，依次类推。32位下，最低的12位是存放页偏移，所以可能的偏移一共有2^12次方，内存中基本的存储单位是1B，所以对应一个帧表的大小是4KB，页表也是4KB。</p>
<p>描述一个物理页的单位叫页帧(page frame)。页帧的尺寸大小和硬件和Linux系统配置有关。对Intel来说，Linux采用4KB页帧大小作为标准内存分配单元。 1. 开启PAE的情况下，为2MB。 1. 如果开启了大页，那么页帧大小为4MB。</p>
<p>页帧之所以选择4KB大小，原因：</p>
<ol type="1">
<li>分页系统造成的缺页异常，要么是页存在但process不被允许访问，要么是页不存在。如果不存在，内存分配器需要找一个free 4KB页帧给process。（这样一来管理虚拟地址空间的分页系统的4KB单位与页帧大小一致，处理起来也就省事。此外，ULK这里的说法是高度抽象的。）</li>
<li>尽管4K和4M都是磁盘块尺寸的倍数，但内存和磁盘间往往传递小块更为的高效。（这是考虑到页的换入换出机制，磁盘IO比内存寻址慢的多，由于进程地址空间是虚拟的，因此CPU和操作系统必须记住哪个页面属于哪个进程以及存储位置。页越大那么单次执行换页操作就越耗时，查找内存映射位置所需的时间就越多。） 处理器分页通常都是支持4KB的页，一个页设得如此之小，造成的一个问题就是页表条目变多，页表size大，TLB miss也增多了。现在它也支持4MB的大页。可以从一定程度上缓解上述问题。</li>
</ol>
<p>win32系统中可使用kernel32.dll中的函数获取页大小： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	SYSTEM_INFO si;</span><br><span class="line">	GetSystemInfo(&amp;si);</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"The page size for this system is %u bytes.\n"</span>, si.dwPageSize);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>memory</category>
      </categories>
  </entry>
  <entry>
    <title>delete-apk</title>
    <url>/2020/03/24/delete-apk/</url>
    <content><![CDATA[<p>系统预装的应用分3种：</p>
<p>不可卸载</p>
<p>这部分没有 root 权限，是不能卸载的。比如 Phone、Message、Calendar 等。</p>
<p>可卸载，可恢复 <a id="more"></a></p>
<p>这部分没有 root 权限，用户也可以卸载，但恢复出厂后又会回来。比如 EMUI 预置的很多第三方的 APP。</p>
<p>可卸载，不恢复</p>
<p>这部分预置在 data 分区，data 分区是用户存储数据的分区，恢复出厂清空数据时也会清理掉这部分 APP。这种情况一般作特殊用途，比如出厂前测试硬件好坏的部分工具 APP，测完恢复出厂，用户也就感觉不到了。</p>
<p>通常说的卸载预置应用是指第1种的，但上面也说了，没有root权限是不能卸载的，实际上本文要介绍的方法处理起来与上面第2种情况类似，虽说可以免root卸载预置应用，但也不是彻底删除APK，让它不可恢复（root后的删除一般是彻底删除）。</p>
<p>首先手机端激活开发者模式，然后连接type-c线到电脑端，cmd shell进入调试模式， 有两种方式可查找要删除的应用名称 1. 使用<code>pm list packages | grep "app"</code>命令查找； 2. 先打开APP，再用<code>dumpsys window | grep mCurrentFocus</code>查看当前界面信息；</p>
<p>然后卸载： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pm uninstall -k --user 0 packageName</span><br></pre></td></tr></table></figure></p>
<p>其中-k 表示保存数据，不需要可去掉 -k。--user 指定用户 id，Android 系统支持多个用户，默认用户只有一个，id=0。</p>
<hr />
<p>Android 调试桥 (adb) 是一种功能多样的命令行工具，可让您与设备进行通信。adb 命令便于执行各种设备操作（例如安装和调试应用），并提供对 Unix shell（可用来在设备上运行各种命令）的访问权限。它是一种客户端-服务器程序，包括以下三个组件：</p>
<p>客户端：用于发送命令。客户端在开发计算机上运行。您可以通过发出 adb 命令从命令行终端调用客户端。</p>
<p>守护进程 (adbd)：在设备上运行命令。守护进程在每个设备上作为后台进程运行。</p>
<p>服务器：管理客户端和守护进程之间的通信。服务器在开发计算机上作为后台进程运行。</p>
<p>adb 包含在 Android SDK 平台工具软件包中。您可以使用 <a href="https://developer.android.com/studio/intro/update.html#sdk-manager" target="_blank" rel="noopener">SDK 管理器</a>下载此软件包，管理器会将此软件包安装在<code>android_sdk/platform-tools/</code>。或者，如果您需要独立的 Android SDK 平台工具软件包，可以点击<a href="https://developer.android.com/studio/releases/platform-tools.html" target="_blank" rel="noopener">此处</a>进行下载。</p>
<p>Windows ADB安装: https://dl.google.com/android/repository/platform-tools-latest-windows.zip</p>
<p>adb 的工作原理</p>
<p>当您启动某个 adb 客户端时，客户端会先检查是否有 adb 服务器进程正在运行。如果没有，它将启动服务器进程。服务器在启动后会与本地 TCP 端口 5037 绑定，并监听 adb 客户端发出的命令 - 所有 adb 客户端均通过端口 5037 与 adb 服务器通信。</p>
<p>然后，服务器会与所有正在运行的设备建立连接。它通过扫描 5555 到 5585 之间（该范围供前 16 个模拟器使用）的奇数号端口查找模拟器。服务器一旦发现 adb 守护进程 (adbd)，便会与相应的端口建立连接。请注意，每个模拟器都使用一对按顺序排列的端口 - 用于控制台连接的偶数号端口和用于 adb 连接的奇数号端口。例如：</p>
<p>模拟器 1，控制台：5554</p>
<p>模拟器 1，adb：5555</p>
<p>模拟器 2，控制台：5556</p>
<p>模拟器 2，adb：5557</p>
<p>依此类推…</p>
<p>如上所示，在端口 5555 处与 adb 连接的模拟器与控制台监听端口为 5554 的模拟器是同一个。</p>
<p>服务器与所有设备均建立连接后，您便可以使用 adb 命令访问这些设备。由于服务器管理与设备的连接，并处理来自多个 adb 客户端的命令，因此您可以从任意客户端（或从某个脚本）控制任意设备。</p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
  </entry>
  <entry>
    <title>display-principel</title>
    <url>/2020/03/24/display-principel/</url>
    <content><![CDATA[<p>转载 <a href="https://zhuanlan.zhihu.com/p/33596570" target="_blank" rel="noopener" class="uri">https://zhuanlan.zhihu.com/p/33596570</a></p>
<h2 id="显示器如何发光">显示器如何发光</h2>
<p>1 光致发光。冷发光的一种，有荧光、磷光或TADF。 2 电致发光。也是冷发光的一种，如阴极射线发光。 <a id="more"></a></p>
<h2 id="发什么光">发什么光</h2>
<p>我们可以发出类似太阳光的光，但是太阳光的波长各种波长都有切连续的，模拟的成本肯定不会低，而且设备的结构会很复杂，不适合装到显示器里面使用。更重要的是，不方便调控颜色。那怎样才能尽可能的减少成本，用简单的结构来发出尽可能多的颜色呢？答案就是最少也要利用三种不同的光来分别刺激L/M/S视锥细胞来实现欺骗大脑的目的。而这三种光的波长大概是位于我们一般意义上认为的红R、绿G、蓝B三种颜色附近。将来如果技术允许的话，整个显示产业链也许会决定增加一种或多种新的原色来实现对更多的色彩的覆盖，但是现阶段因为成本与效率之间的考虑，显示器要发的光就只是R、G、B三种光，而数字化的颜色信息也只需要存储与传输三种颜色的信息就可以了。显示器的色域的提高就是要改善R、G、B的定义，但是这些改善需要软件的配合。目前的显示设备在宣传的时候一般会和NTSC或者Adobe RGB标准(这个两个相差不大）做比较，稍微差点的会和sRGB作比较，好一点的会和DCI-P3做比较。这些英文缩写都是行业组织或者公司制定的显示标准，这些标准都会对R、G、B三者的值进行定义，而显示器自身也会有其硬件允许的R、G、B数值，将显示器的三角形与行业标准的三角形进行比较，如果能够覆盖行业标准的80%，就可以说达到某某标准的80%。其实颜色的准确度不仅仅和色域有关，也和显示器内部的主控芯片以及输出信号的系统有很大关系。色域相当于是硬件，信号和芯片相当于是软件。硬件都听软件的，芯片需要能够接收到合适的信号并准确的指挥显示器来显示出正确的颜色。有一些没有良心的厂家，总是宣传自己可以表现出多少多少颜色，而不是自己能够覆盖多少色域，偷换概念。这就好像0和1之间有无数个数字，但是没有一个会比2大。靠增加颜色的渐变的精细度可以增加同样范围内的颜色的数量，但是并不能扩大颜色的范围。这其实是把颜色编码从8位升到10位的效果，而且很有可能不是真的硬升级。总的来说，三种颜色应该是均衡的，但是因为人眼对于波长550nm左右的绿色光最为敏感，这个波长的光不仅仅能够传递自身的颜色信息，还能够比其他颜色更有效率的传递明暗信息，所以有一些显示器会更为强调这个波长的光。</p>
<h2 id="光的控制">光的控制</h2>
<p>显示器不仅要能发光，还要能够控制光在不同的子像素处表现不同的明暗/颜色值来传递信息。</p>
<p>栅格化的方式要求显示器能够控制每个（子）像素的：</p>
<p>明暗信息 颜色信息</p>
<p>但是，如果我们采用上面所说的R、G、B三种颜色的方式，那么这两种信息归根结底，可以合并量化为R的明暗信息、G的明暗信息以及B的明暗信息。</p>
<p>进一步说，我们需要控制人眼接受到的R波长的电磁波的量的多少、G波长的电磁波的量的多少以及B波长的电磁波的量的多少。</p>
<p>有两种思路可以实现这个目的：</p>
<ol type="1">
<li>通过调节给予发光材料的能量来控制发出的光的量。 比较典型的例子有OLED、等离子电视、CRT显像管老电视、LCD等。</li>
<li>保持发光材料发出的光的量不变，但是在人眼和发光材料之间设置某种可以调节的阀门来控制最终可以进入人眼的光的的量，比如液晶体。 比较典型的例子有LCD(并非笔误导致的重复）、DLP、电影胶片等。</li>
</ol>
<p>“调节”本身也可以有两种方式：</p>
<p>一种是密度法，发出能量的时间或者阀门开放的时间是保持一致不变的，但是单位时间发出的能量的量，或者阀门的口径是可以调节的。具体方法一般是调节电压强度或者电流强度。 采用这种方式的有LCD、一部分LG的OLED、CRT、Single/Three Chip LCD投影等等</p>
<p>一种是时间法，保持发光材料发出的能量强度，或者阀门的口径不变，但是调节发光的时间，或者阀门开放的时间。这种一般是采用所谓PWM（Pulse-Wideth Modulation)脉冲宽度调制法</p>
<p>采用这种方式的有LCD(并非笔误导致的重复）、等离子电视、三星的OLED、一部分LG的OLED、Single/Three Chip DLP、SED、FED等等。</p>
<p>另外，R、G、B也有两种方式可以实现:</p>
<p>一是为每个颜色做一个子像素，并且以某种方式在空间上将R、G、B排列在一起。因为子像素之间的距离非常近，所以人眼会把这几个子像素看成同一个“大”像素，也会将这几个子像素的颜色混在一起当做一个像素来看。当然，因为使用扫描的方式，所以即使是同一个“大”像素，子像素的输出也是有时间先后次序的，并不是同时发光的。 这种方式是目前的主流，主要有LCD、OLED、等离子、CRT、Three Chip DLP、Three Chip LCD投影等等。</p>
<p>二是不在物理上对像素进行空间上的区分，在同一个像素上可以给予R、G、B三个颜色各自一定的时间，按照顺序来分别输出光，如果切换的速度够快，也是会让人眼自动将三种颜色混合在一起看的。</p>
<p>采用这种方式的有Single Chip DLP, Single Chip LCD投影以及大多数中低端LCD显示器上使用的FRC技术（所谓“抖”色技术）等。</p>
<p>上面这三个要素，各有两种方式，可以自由组合，一共2 x 2 x 2 = 8种可能，虽然可能有些组合并没有实际的产品。</p>
<p>也有可能一些产品会同时利用同一个要素的两种方式，比如，现在的主流的产品LCD就是阀门调节+发光材料调节、密度调节、物理R。</p>
<p>三星的OLED则是发光材料调节、时间调节、物理R。已经被淘汰的等离子电视是发光材料调节、时间调节、物理R。家用的Single Chip DLP投影是阀门调节、时间调节、按时序切换R，而电影院的数字IMAX则是Three Chip DLP技术，采用了阀门调节、时间调节、物理R。</p>
<p>说到IMAX，胶片电影这种传统显示方式其实很特别。硬要分类的话，其实是阀门调节、速度调节、物理CMY子像素（胶片是采用CMY三原色减色法）。</p>
<p>每一张胶片相当于是为每一帧画面特制的一张滤光片Color Filter，因为每一帧都有预先准备好的专用Filter，所以胶片电影也是属于一种非常特别的不使用像素扫描法的显示方式，其代价就是成本与体积，而其他的显示方式都要想办法去扫描，无论采用上面说的哪一种组合方式。</p>
<p>但是，具体我们是如何控制并如何扫描这些像素的呢？Well，前面我们提到了芯片。是的，显示器内部都是有芯片来负责接收与处理接受到的信息，再把这些信息翻译成可以听懂的指令以后发送给各个像素，而这些指令一般是以电压或电流的方式来表达的。为了能够传达指令，这些像素需要以某种形式被连接起来。</p>
<p>目前比较普遍的方式叫TFT。</p>
<p>理想的连接形式，应该是每一个像素都是直接和芯片连接，芯片可以直接控制每一个像素。但是这样的话就意味着我们需要为每一个像素单独制造一条通往芯片的电路。但是这样的话，一块1080P FHD的屏幕就需要600多万条电路通向芯片，这无疑是非常难以实现的，而且对芯片的控制能力也是一个挑战。</p>
<p>这种情况下，最好的解决办法无疑就是分组了。</p>
]]></content>
      <categories>
        <category>display</category>
      </categories>
  </entry>
  <entry>
    <title>pc-hardware-architecture</title>
    <url>/2020/03/24/pc-hardware-architecture/</url>
    <content><![CDATA[<h2 id="几种计算机基本架构框图">几种计算机基本架构框图</h2>
<p>传统PC的高级框图。北桥包含高带宽接口，连接CPU，内存和PCI总线。 南桥包含传统接口和设备：ISA总线（音频，LAN），中断控制器; DMA控制器;定时/计数器。 在该系统中，显示器由称为VGA（视频图形阵列）的简单帧缓冲子系统驱动，该子系统连接到PCI总线。 1990年的PC环境中不存在具有内置处理元件（GPU）的图形子系统。 <a id="more"></a></p>
<p><img src="/images/historical-pc.png" alt="historical" /> 目前常用的两种配置。 它们的特征在于独立GPU和具有相应存储器子系统的CPU。 图中，使用Intel CPU，GPU通过16通道PCI-Express 2.0链路连接，提供16 GB / s的峰值传输速率（每个方向的峰值为8 GB / s）。 <img src="/images/contemporary-pc.png" alt="contemporary" /> 当今的GPU使用统一架构 <img src="/images/unified-gpu-arch.png" alt="unified gpu" /> 从Fermi开始NVIDIA使用一个Giga Thread Engine来管理所有正在进行的工作，GPU被划分成多个GPCs(Graphics Processing Cluster)，每个GPC拥有多个SM（SMX、SMM）和一个光栅化引擎(Raster Engine)，它们其中有很多的连接，最显著的是Crossbar，它可以连接GPCs和其它功能性模块（例如ROP）。</p>
<p>对于某些GPU（如Fermi部分型号）的单个SM，包含：</p>
<ul>
<li>32个运算核心 （Core，也叫流处理器Stream Processor）</li>
<li>16个LD/ST（load/store）模块来加载和存储数据</li>
<li>4个SFU（Special function units）执行特殊数学运算（sin、cos、log等）</li>
<li>128KB寄存器（Register File）</li>
<li>64KB L1缓存</li>
<li>全局内存缓存（Uniform Cache）</li>
<li>纹理读取单元</li>
<li>纹理缓存（Texture Cache）</li>
<li>PolyMorph Engine：多边形引擎负责属性装配（attribute Setup）、顶点拉取(VertexFetch)、曲面细分、栅格化（这个模块可以理解专门处理顶点相关的东西）。</li>
<li>2个Warp Schedulers：这个模块负责warp调度，一个warp由32个线程组成，warp调度器的指令通过Dispatch Units送到Core执行。</li>
<li>指令缓存（Instruction Cache）</li>
<li>内部链接网络（Interconnect Network）</li>
</ul>
<p>在Pascal中，一个SM（流式多处理器）由128个CUDA内核组成。GP100 SM分为两个处理模块，每个模块具有32位单精度CUDA内核，一个指令缓冲区，一个warp调度程序，2个纹理映射单元和2个调度单元。使用统一内存体系结构，借助称为“页面迁移引擎”的技术，CPU和GPU可以同时访问主系统内存和图形卡上的内存。</p>
<p>渲染输出单元(ROP)是现代图形处理器（GPU）最后硬件组件，和在渲染过程的最后步骤之一。绘图管线取像素（每个像素是一个无量纲点），和纹理像素信息，并处理它，经由特定的矩阵和向量运算，变成最终像素或深度值。此过程称为栅格化。当多个样本合并为一个像素时，渲染输出单元控制抗锯齿。 渲染输出单元执行本地存储器中相关缓冲区之间的事务 - 这包括写入或读取值，以及将它们混合在一起。用于执行基于硬件的抗锯齿方法（如多重采样抗锯齿(MSAA)）的专用抗锯齿硬件包含在渲染输出单元中。渲染的所有数据都必须通过渲染输出单元才能写入帧缓冲器，帧缓冲器再传输到VGA、DVI、HDMI、Displayport、 Mini Displayport线到显示器。历史上，渲染输出单元，纹理映射单元和着色器处理单元/ 流处理器的数量是相等的。然而，从2004年开始，几个GPU已经将这些区域分离，以便为应用程序工作负载和可用内存性能提供最佳的晶体管分配。随着趋势的继续，预计图形处理器将继续解耦其架构的各个部分，以增强其对未来图形应用程序的适应性。这种设计还允许芯片制造商构建模块化阵容，其中顶级GPU基本上使用与低端产品相同的逻辑。</p>
<h2 id="h和cm246芯片组">8750H和CM246芯片组</h2>
<h3 id="coffee-lake架构框图">coffee lake架构框图</h3>
<p>x1e的i7-8750H和CM246芯片组，都基于coffee lake架构，架构框图如下： <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cuaW50ZWwuY29tL2NvbnRlbnQvZGFtL3d3dy9wcm9ncmFtL2Rlc2lnbi91cy9lbi9pbWFnZXMvMTZ4OS9jb2ZmZWUtbGFrZS1oLWJsb2NrLWRpYWdyYW0tMTZ4OS5wbmc?x-oss-process=image/format,png" alt="coffee lake" /> 该芯片组PCH 上有多达 30 个高速 I/O 通道，详细图如下： <img src="https://imgconvert.csdnimg.cn/aHR0cDovL2xpbnV4Z2l6bW9zLmNvbS9maWxlcy9jb25nYXRlY19jb25nYXRzMzcwX2Jsb2NrLmpwZw?x-oss-process=image/format,png" alt="coffee lake detail" /> 概览图如下： <img src="https://img-blog.csdnimg.cn/20190912202640673.jpg" alt="概览图" /></p>
<h3 id="coffee-lake系统芯片组成">coffee lake系统芯片组成</h3>
<p>Coffee Lake系统芯片由五个主要组件组成：CPU ，LLC，环形互连，系统代理和集成显卡。自2011年推出Sandy Bridge以来，Coffee Lake是英特尔主流微体系结构的最大变化。2006年，英特尔推出了第一款主流四核处理器Core 2 Extreme QX6700，该处理器基于Kentsfield核心。 这些四核处理器由两个独立的管芯组成，这些管芯在多芯片封装中互连。前端总线用作芯片到芯片（die-to-die）的链接，后来到Penryn平台这种配置并没有改变，直到2008年推出基于Nehalem微体系结构的Core i7，Nehalem将所有四个内核整合到一个芯片上并进行大量更改，特别是增强uncore（现在称为系统代理）。 Core i7-980X也是第一款六核用户芯片。 <img src="https://img-blog.csdnimg.cn/20190912205058703.png" alt="nehalem" /> SoC整体概览(hexa): <img src="https://img-blog.csdnimg.cn/20190912210031938.png" alt="hexa soc" /> 单核框图： <img src="https://img-blog.csdnimg.cn/20190912210402867.png" alt="single core" /> 随着2011年Sandy Bridge的推出，整个系统架构进行了重新设计。 Sandy Bridge的一个特殊目标是其可配置性。 英特尔希望能够在多个细分市场中使用单一设计，而无需在多个物理设计上花费额外资源。其模块化的很大一部分来自Sandy Bridge实现的环形互连（Last Level Cache）。  该环允许英特尔在Sandy Bridge中集成System Agent和集成显卡。 <img src="https://img-blog.csdnimg.cn/20190912211124625.png" alt="ring" /> 这些组件中的每一个都有自己的环代理（除了单个核心），允许在GPU，SA以及各个核心和高速缓存之间有效地传输数据。 最终结果是一个完整的片上系统（SoC）在单个裸片上有四个内核和一个12 EU GPU。</p>
<p>由于Coffee Lake采用了英特尔第三代增强型14nm成熟工艺，因此英特尔可以将核心数量从4核增加到6核。 现有的环形互连专门设计用于支持此配置。 除了两个添加的核心之外，还有两个额外的LLC切片。 <img src="https://img-blog.csdnimg.cn/20190912211925596.png" alt="llc" /> coffee lake环示意图： <img src="https://img-blog.csdnimg.cn/20190912212239785.png" alt="coffee lake ring" /> 新的十一代cpu架构： <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cuZXh0cmVtZXRlY2guY29tL3dwLWNvbnRlbnQvdXBsb2Fkcy8yMDE5LzAzL0ludGVsLUdQVS0xLmpwZw?x-oss-process=image/format,png" alt="11gen cpu" /> ps:工艺制造中lot指按某种方式生成的硅柱状体，将这些lot切成薄片就称为wafer，wafer是进行集成电路制造的基板，一般以直径来区分，8寸、10寸，12寸等，或者以毫米来区分。直径越大材料的利用率越高，因为在wafer的周边由于弧形的关系是没法利用的 。在wafer上根据需要划分不同的区域，每个区域用于生产特定功能的芯片，称之为<strong>die</strong>。总的来说，Die或CPU Die指的是处理器在生产过程中，从晶圆（Silicon Wafer）上切割下来的一个个小方块（常见CPU芯片都是方形），在切割下来之前，每个小方块（Die）都需要经过各种加工，将电路逻辑刻到该Die上面。die-to-die即芯片对芯片。 <img src="https://img-blog.csdnimg.cn/20181202091655735.png" alt="die" /> 对于主流的CPU厂商Intel和AMD而言，他们会将1个或者N个CPU Die封装起来形成一个CPU Package，有时候也叫作CPU Socket。</p>
<h2 id="总线">总线</h2>
<p>总线是在计算机部件之间或计算机之间传输数据的子系统。 类型包括：</p>
<ul>
<li><strong>前端总线（FSB）</strong> 它在CPU和内存控制器之间传输数据。</li>
<li><strong>直接媒体接口（DMI）</strong> 它是英特尔集成内存控制器和计算机主板上的英特尔I/O控制器中心之间的点对点互连;用于主板上南桥芯片和北桥芯片之间的连接。DMI与PCIe总线共享了大量的技术特性，像是多通道、差分信号、点对点连线、全双工、8b/10b编码等。大部分DMI的通信布局类似于PCIe x4规格。DMI 3.0于2015年8月发布，每通道可拥有最大8GT/s的吞吐量（8750H的总线速度，也就是说x1e支持DMI3.0的总线接口，其前端总线接口为BCLK），x4规格时有3.93GB/s的带宽。也用于CPU与PCH的连接。</li>
<li><strong>快速通道互连（QPI）</strong> 它是CPU和集成内存控制器(IMC)之间的点对点互连。</li>
</ul>
<p>在传统架构中，前端总线充当CPU与系统中所有其他设备（包括主存储器）之间的直接数据链路。在基于HyperTransport和QPI的系统中，系统存储器通过集成在CPU 中的内存控制器独立访问，留下HyperTransport或QPI链路上的带宽用于其他用途。这增加了CPU设计的复杂性，但在多处理器系统中提供了更高的吞吐量和出色的扩展性。Core i7-8750H就使用的IMC，如下所示 |属性|参数| |----|----| |最大类型|DDR4-2666，LPDDR3-2133| |支持ECC|否| |最大内存|64 GiB| |控制器|1| |通道|2| |宽度|64位| |最大带宽|（39.74GiB/s？）41.8GB/s| |带宽|单通道：19.87GiB/s；双通道：39.74GiB/s| 其中最大带宽是处理器可以从半导体存储器读取数据或将数据存储到半导体存储器中的最大速率（以GB/s为单位）。 - <strong>PCI-E</strong> Peripheral Component Interconnect Express（或PCIe）是一种高速串行计算机扩展总线标准，用于将硬件设备连接到计算机。不同的PCI Express版本支持不同的数据速率。 <img src="/images/pcie-speed.png" alt="pciespeed" /> 我们看到X1，X2，X4…是指PCIe连接的通道数（Lane）。</p>
<p>PCI-E串行总线带宽（MB/s） = 串行总线时钟频率（MHz）x串行总线位宽（bit/8 = B）x 串行总线管线x 编码方式x 每时钟传输几组数据（cycle），例：双工PCI-E 1.0 X1，其带宽 = 2500x1/8x1x8/10x1x2=500 MB/s。</p>
<p>两个设备之间的PCIe连接，叫做一个Link，如下图所示： <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9taWFvLnN1L2ltYWdlcy8yMDE4LzA0LzEzLzhlYjY4NGIzZWRiZTQ3NjI3ZTgwNi5wbmc?x-oss-process=image/format,png" alt="pcielink" /> PCI-e是全双工，发送和接收可以同时进行，而且没有时钟线，它是采用8/10和128/130的编码方式把时钟编入传输信号内的。PCI-e3.0可是工作在4Ghz的频率上。PCIe链路使用串行方式进行数据传送，然而在芯片内部，数据总线仍然是并行的，因此PCIe链路接口需要进行串并转换，这种串并转换将产生较大的延时。除此之外PCIe总线的数据报文需要经过事务层、数据链路层和物理层，这些数据报文在穿越这些层次时，也将带来延时。在4Ghz的频率下，任何一点延时都会带来问题。</p>
<p>两个PCIe设备之间，有专门的发送和接收通道，数据可以同时往两个方向传输，PCIe spec称这种工作模式为双单工模式（dual-simplex）。前面PCIe带宽那张表，上面的带宽，比如PCIe3.0x1，带宽为2GB/s，是指双向带宽，即读写带宽。如果单指读或者写，该值应该减半，即1GB/s的读速度或者写速度。</p>
<p>传输速率为每秒传输量GT/s，而不是每秒位数Gbps，因为传输量包括不提供额外吞吐量的开销位； 比如 PCIe 1.x和PCIe 2.x使用8b / 10b编码方案，导致占用了20% （= 2/10）的原始信道带宽。</p>
<p>GT/s —— Giga transation per second （千兆传输/秒），即每一秒内传输的次数。重点在于描述物理层通信协议的速率属性，可以不和链路宽度等关联。GT/s 与Gbps 之间不存在成比例的换算关系。</p>
<p>PCIe 吞吐量（可用带宽）计算方法：</p>
<p>吞吐量 = 传输速率 *  编码方案</p>
<p>例如：PCI-e2.0 协议支持 5.0 GT/s，即每一条Lane 上支持每秒钟内传输 5G个Bit；但这并不意味着 PCIe 2.0协议的每一条Lane支持 5Gbps 的速率。因为PCIe 2.0 的物理层协议中使用的是 8b/10b 的编码方案。 即每传输8个Bit，需要发送10个Bit。</p>
<p>那么， PCIe 2.0协议的每一条Lane支持 5 * 8 / 10 = 4 Gbps = 500 MB/s 的速率。</p>
<p>以一个PCIe 2.0 x8的通道为例，x8的可用带宽为 4 * 8 = 32 Gbps = 4 GB/s。 <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMuYW5hbmR0ZWNoLmNvbS9yZXZpZXdzL2NoaXBzZXRzLzIwMDgvcGNpZS0yLjAvQldfVGFibGUucG5n?x-oss-process=image/format,png" alt="pciespeedcalc" /> 经检测，x1e使用的m.2280的nvme接口为PCI-E 2.0x4，速率2GB/s，另外雷电3的桥接也使用该规格。而北桥除了内存控制器之外，还有1050Ti显卡使用了PCI-E 2.0x16的控制器，速率8GB/s。</p>
<h2 id="计算机内存">计算机内存</h2>
<h3 id="计算机内存历史">计算机内存历史</h3>
<p>内存有多种形式，但是在非易失性内存（NVM）出现之前，计算世界首先以随机存取内存（RAM）的形式引入易失性内存。RAM引入了在相同的时间内向/从存储介质的任何位置写入/读取数据的功能。特定数据集通常是随机的物理位置，并不影响操作完成的速度。通过缓存经常读取的数据或暂存需要写入的数据，这种类型的内存的使用掩盖了从指数级较慢的HDD访问数据的痛苦。</p>
<p>RAM技术中最著名的是动态随机存取存储器（DRAM）。硬盘驱动器十年后的1966年，它也从IBM实验室出来。DRAM与CPU距离更近，并且也不必处理机械组件（即HDD），因此其运行速度非常快。即使在今天，许多数据存储技术都在努力以DRAM的速度运行。但是这有一个缺点：一旦电容器驱动的集成电路（IC）断电，数据就会随之消失。</p>
<p>DRAM技术的另一缺点是其容量非常低，每GB的价格也很高。即使按照今天的标准，与较慢的HDD和SSD相比，DRAM还是太昂贵了。</p>
<p>DRAM首次亮相后不久，便出现了可擦可编程只读存储器（EPROM）。它是由英特尔发明的，于1971年左右问世。与易失性同类产品不同，EPROM内存在系统电源关闭后立即保留其数据。EPROM在其IC中使用晶体管代替电容器。这些晶体管即使在断电后也能够保持状态。 顾名思义，EPROM属于其自己的只读存储器（ROM）类。通常，数据是使用特殊的设备或工具预先编程到这些芯片中的，而在生产时，它的目的是唯一的：从高速读取数据。这种设计的结果是，EPROM立即在嵌入式和BIOS应用程序中变得很流行，后者则存储了特定于供应商的详细信息和配置。</p>
<h3 id="i7-8750h内存带宽">i7-8750H内存带宽</h3>
<p>4GHz频率的i7-8750H中的集成内存控制器IMC上的16GB2双通道DDR4-2666总内存带宽约为40GB/s，如图所示。</p>
<ul>
<li>单通道 <img src="https://s1.51cto.com/images/blog/201909/12/e5bfefaa9a5fe7ac87eb08cb97c3b9a9.png" alt="single" /></li>
<li>双通道 <img src="https://s1.51cto.com/images/blog/201909/12/9cc33cb3fd63c3f4d34a6ddcb9b42566.png" alt="double" /></li>
</ul>
<h3 id="gpu显存特点">GPU显存特点</h3>
<p>一是GPU的显存带宽较大。理论上常见GPU使用的16通道PCIe 2.0接口的峰值带宽约8GB/s，像GeForce GTX1080 Ti显卡的显存带宽接近500GB/s。二是GPU的显存访问延迟较大。GPU是为高吞吐量而非低延迟构建的，因此从缓存延迟到全局内存延迟往往比CPU更高。在i7-8750H上主内存没有命中缓存的情况，大约需要4GHz64ns=256个时钟周期来获取数据。PCIe接口的GPU全局内存没有命中缓存的情况，需要延迟大约400以上的时钟周期。</p>
<h3 id="nvme">NVMe</h3>
<h4 id="hdd">HDD</h4>
<p>IBM于1956年首次亮相HDD。到1960年代，HDD成为通用计算机中占主导地位的辅助存储设备。容量和性能是定义HDD的主要特征。</p>
<p>IBM制造的第一个硬盘驱动器350 RAMAC与两个中型冰箱一样大，在50个磁盘的堆栈上总容量为3.75MB。现代HDD技术已生产出容量高达16TB的磁盘驱动器，特别是结合了SMR技术和氦气。密封的氦气增加了驱动器的潜在速度，同时减少了阻力和湍流。由于密度不如空气，因此还可以在2.5英寸和3.5英寸常规磁盘驱动器使用的相同空间中堆叠更多的磁盘。</p>
<p>磁盘驱动器的性能通常由将驱动器磁头移动到特定磁道或圆柱体所需的时间以及请求的扇区在磁头下移动所需的时间（即延迟）来计算。还以传输数据的速率来衡量性能。</p>
<p>作为机械设备，HDD的不如内存快。许多移动组件增加了等待时间，并降低了访问数据的整体速度（用于读取和写入操作）。</p>
<p>每个HDD的内部都有磁性磁盘，通常称为磁盘。这些拼盘是存储信息的地方。HDD由一根主轴绑定并一致地旋转，一个HDD将有一个以上的盘片并排放置，它们之间的空间最小。</p>
<p>与留声机唱片的工作原理类似，唱片是双面的，每个唱片的表面都有圆形的蚀刻，称为轨道。每个轨道由扇区组成。随着靠近盘片边缘，每个轨道上的扇区数都会增加。如今，您会发现一个扇区的物理大小为512字节或4千字节（4096字节）。在编程中，扇区通常等同于磁盘块。</p>
<p>磁盘旋转的速度会影响信息的读取速度。这定义为磁盘的旋转速率，以每分钟转数（RPM）进行测量。这就是为什么现代驱动器以7200 RPM（或每秒120转）的速度运行的原因。较旧的驱动器以较低的速度旋转。高端驱动器可能以更高的速度旋转。此限制造成了瓶颈。</p>
<p>执行器臂位于盘片上方或下方。它在其表面上延伸和缩回。手臂末端是一个读写头。它位于盘子表面上方的微观距离处。随着磁盘旋转，磁头可以访问当前磁道上的信息（不移动）。但是，如果磁头需要移动到下一个轨道或完全不同的轨道，则会增加读取或写入数据的时间。从程序员的角度来看，这称为磁盘搜索，这造成了第二个瓶颈。 现在，尽管通过更新的磁盘访问协议（例如串行ATA（SATA）和串行连接的SCSI（SAS））和技术，HDD的性能一直在提高，但它仍然是CPU以及整个计算机系统的瓶颈。每个磁盘协议对最大吞吐量（每秒兆字节或千兆字节）都有自己的硬性限制。数据传输的方法也非常串行化。这在旋转的磁盘上很好用，但不能很好地扩展到Flash技术。</p>
<h4 id="ssd">SSD</h4>
<p>近年来，固态硬盘（SSD）的市场份额持续攀升，取代了许多行业的HDD。当第一批商用SSD进入市场时，公司和个人都很快就采用了该技术。即使价格更高，与HDD相比，人们还是能够证明其合理性。时间就是金钱，如果访问驱动器可以节省时间，则可能会增加利润。但不幸的是，随着第一个基于NAND的商业化SSD的推出，该驱动器并没有将数据存储移到更靠近CPU的地方。这是因为早期的供应商选择采用现有的磁盘接口协议，例如SATA和SAS。该决定的确鼓励了消费者的采用，但同样它限制了整体吞吐量。</p>
<p>尽管SSD并没有靠近CPU，但它的确实现了该技术的新里程碑-减少了跨存储介质的寻道时间，从而大大减少了延迟。这是因为驱动器是围绕IC设计的，并且不包含可移动组件。SSD不会将数据保存到旋转磁盘上，而是将相同的数据保存到NAND闪存池中。NAND技术与DRAM中使用的晶体管设计（必须每秒刷新多次）不同，NAND即使在没有电源的情况下也能够保持其充电状态，因此是非易失性的。</p>
<p>M-Systems于1995年推出了第一款无需电源（即电池）即可维持状态的正式SSD。它们旨在替代军事和航空航天应用关键任务中的HDD。到1999年，以传统的3.5英寸存储驱动器外形设计并提供了基于闪存的技术，并且一直以这种方式进行开发，直到2007年新成立的革命性初创公司Fusion-io（现已成为Western Digital的一部分）决定改变传统存储驱动器的性能极限形式，并将该技术直接应用于PCI Express（PCIe）总线，这种方法消除了许多不必要的通信协议和子系统，设计也离CPU越来越近，并产生了明显的性能改进。</p>
<p>后来，Fusion-io的产品启发了其他内存和存储公司，将一些类似的技术引入了双列直插式内存模块（DIMM）尺寸，该尺寸可直接插入支持的主板的传统RAM插槽中。这些类型的模块作为不同的内存类别注册到CPU，并保持某种程度的保护模式。除非通过专门设计的设备驱动程序或应用程序接口完成操作，否则主系统以及相应的操作系统都不会接触这些存储设备。</p>
<p>在这里还值得注意的是，与DRAM性能相比，基于晶体管的NAND闪存技术仍然显得苍白。我说的是微秒延迟与DRAM的纳秒延迟。即使采用DIMM尺寸，基于NAND的模块的性能也不如DRAM模块好。</p>
<h4 id="靠近cpu">靠近CPU</h4>
<p>显而易见，将数据（存储）移到CPU越近，访问（和操作）数据的速度就越快。最接近CPU的内存是处理器的寄存器。处理器可用的寄存器数量因体系结构而异。该寄存器的目的是保存少量打算用于快速存储的数据。毫无疑问，这些寄存器是访问小尺寸数据的最快方法。</p>
<p>接下来，紧随CPU的寄存器的是CPU缓存。这是内置在处理器模块中的硬件高速缓存，CPU可以利用它来减少从主存储器（DRAM）访问数据的成本和时间。它是围绕静态随机存取存储器（SRAM）技术设计的，该技术也是一种易失性存储器。像典型的高速缓存一样，此CPU高速缓存的目的是存储来自最频繁使用的主内存位置的数据副本。在现代CPU架构上，存在多个不同的独立缓存（并且其中一些缓存甚至被拆分了）。它们按照缓存级别的层次结构进行组织：级别1（L1），级别2（L2），级别3（L3），依此类推。处理器越大，缓存级别越多，级别越高，它可以存储的内存就越多（即从KB到MB），其位置离主CPU越远，但它也确实引入了延迟。</p>
<p>首次使用处理器中的高速缓存的记录可以追溯到1969年，然后是IBM System/360 Model 85大型机。直到1980年代，更主流的微处理器才开始合并自己的CPU缓存。部分原因是成本。就像今天一样，（所有类型的）RAM非常昂贵。 因此，数据访问模型是这样的：离CPU越远，延迟就越大。DRAM的位置比HDD位置更靠近CPU，但不及IC中设计的寄存器或高速缓存级别那么近。</p>
<h4 id="非易失性内存expressnvme">非易失性内存Express（NVMe）</h4>
<p>NVMe（非易失性内存Express，或称非易失性内存主机控制器接口规范）是一种用于访问高速存储介质的新协议，该协议是相对较新的，功能丰富的协议，它是专为通过PCIe接口直接连接到CPU的非易失性存储介质（NAND和持久性存储器）而设计的。该协议建立在高速PCIe通道上。PCIe Gen 3.0链接可提供的传输速度是SATA接口的两倍以上。 <img src="https://s1.51cto.com/images/blog/201910/27/9c9e7fcbc45a09ce3065d217cccca625.png" alt="nvme" /> NVMe协议利用到底层介质的并行，低延迟数据路径，类似于高性能处理器体系结构。与传统的SAS和SATA协议相比，这提供了显着更高的性能和更低的延迟。</p>
<p>Fusion-io构建了封闭的专有产品。仅这一事实就吸引了许多行业领导者共同定义新标准，以与先驱竞争，并将更多的PCIe连接的闪存推入数据中心。拥有行业第一规范NVMe在2011年宣布推出后，迅速上升到SSD技术的最前沿。请记住，从历史上看，SSD是基于SATA和SAS总线构建的。这些接口对于成熟的闪存技术工作得很好，但是在所有协议开销和总线速度限制的情况下，这些驱动器很快就经历自己的合理性能瓶颈（和限制）。如今，现代SAS驱动器以12Gbit / s的速度运行，而现代SATA驱动器以6Gbit / s的速度运行。这就是为什么该技术将重点转移到PCIe的原因。随着总线距离CPU越来越近，PCIe能够以越来越高的速度运行，SSD似乎正好适合。使用PCIe 3.0，现代驱动器可以达到40Gbit / s的速度。对NVMe驱动器的支持已集成到Linux 3.3主线内核（2012年）中。</p>
<p>NVMe真正使操作系统的旧式存储堆栈大放异彩的原因在于其更简单，更快速的排队机制。这些称为提交队列（SQ）和完成队列（CQ）。每个队列都是固定大小的循环缓冲区，操作系统使用该缓冲区将一个或多个命令提交给NVMe控制器。这些队列中的一个或多个也可以固定到特定的内核，这样可以进行更多不间断的操作。再见串行通讯。现在驱动器I/O已并行化。</p>
<h4 id="nvmeof">NVMeoF</h4>
<p>在SAS或SATA的世界中，有存储区域网络（SAN）。SAN是根据SCSI标准设计的。SAN（或任何其他存储网络）的主要目标是通过一条或多条路径提供对一个或多个存储卷的访问，以访问网络中的一个或多个操作系统主机。如今，最常用的SAN基于iSCSI，即基于TCP / IP的SCSI。从技术上讲，NVMe驱动器可以在SAN环境中进行配置，尽管协议开销会引入延迟，这使其成为不太理想的实现方式。2014年，NVMe Express委员会准备采用NVMeoF标准进行纠正。</p>
<p>NVMeoF的目标很简单：启用围绕NVMe排队体系结构构建的NVMe传输桥，并避免支持的NVMe命令（端到端）以外的任何协议转换开销。通过这种设计，网络等待时间会明显下降（小于200ns）。此设计依赖于PCIe交换机的使用。基于使用远程直接内存访问（RDMA）的现有以太网结构的第二种设计正在取得进展。</p>
<p>Linux内核引入了许多支持NVMeoF的新代码。这些补丁是英特尔，三星和其他地方的辛勤工作的开发人员共同努力的一部分。内核中修补了三个主要组件，包括常规的NVMe Target Support框架。该框架使模块设备可以使用NVMe协议从Linux内核中导出。依赖于此框架，现在支持NVMe环回设备以及基于Fabrics RDMA目标的NVMe。如果您还记得的话，这最后一部分是另外两个常见的NVMeoF部署之一。</p>
<h2 id="参考">参考</h2>
<p><a href="https://en.wikichip.org/wiki/WikiChip" target="_blank" rel="noopener">wikichip</a></p>
]]></content>
      <categories>
        <category>GPU</category>
      </categories>
      <tags>
        <tag>architecture</tag>
      </tags>
  </entry>
  <entry>
    <title>nvidia-gpu-logical-pipeline</title>
    <url>/2020/03/24/nvidia-gpu-logical-pipeline/</url>
    <content><![CDATA[<ol type="1">
<li><p>程序通过图形API(DX、GL、WEBGL)发出drawcall指令，指令会被推送到驱动程序，驱动会检查指令的合法性，然后会把指令放到GPU可以读取的Pushbuffer中。 <a id="more"></a></p></li>
<li><p>经过一段时间或者显式调用flush指令后，驱动程序把Pushbuffer的内容发送给GPU，GPU通过主机接口（Host Interface）接受这些命令，并通过前端（Front End）处理这些命令。</p></li>
<li><p>在图元分配器(Primitive Distributor)中开始工作分配，处理indexbuffer中的顶点产生三角形分成批次(batches)，然后发送给多个PGCs。这一步的理解就是提交上来n个三角形，分配给这几个PGC同时处理。</p></li>
<li><p>在GPC中，每个SM中的Poly Morph Engine负责通过三角形索引(triangle indices)取出三角形的数据(vertex data)，即图中的Vertex Fetch模块。</p></li>
<li><p>在获取数据之后，在SM中以32个线程为一组的线程束(Warp)来调度，来开始处理顶点数据。Warp是典型的单指令多线程（SIMT，SIMD单指令多数据的升级）的实现，也就是32个线程同时执行的指令是一模一样的，只是线程数据不一样，这样的好处就是一个warp只需要一个套逻辑对指令进行解码和执行就可以了，芯片可以做的更小更快，之所以可以这么做是由于GPU需要处理的任务是天然并行的。</p></li>
<li><p>SM的warp调度器会按照顺序分发指令给整个warp，单个warp中的线程会锁步(lock-step)执行各自的指令，如果线程碰到不激活执行的情况也会被遮掩(be masked out)。被遮掩的原因有很多，例如当前的指令是if(true)的分支，但是当前线程的数据的条件是false，或者循环的次数不一样（比如for循环次数n不是常量，或被break提前终止了但是别的还在走），因此在shader中的分支会显著增加时间消耗，在一个warp中的分支除非32个线程都走到if或者else里面，否则相当于所有的分支都走了一遍，线程不能独立执行指令而是以warp为单位，而这些warp之间才是独立的。</p></li>
<li><p>warp中的指令可以被一次完成，也可能经过多次调度，例如通常SM中的LD/ST(加载存取)单元数量明显少于基础数学操作单元。</p></li>
<li><p>由于某些指令比其他指令需要更长的时间才能完成，特别是内存加载，warp调度器可能会简单地切换到另一个没有内存等待的warp，这是GPU如何克服内存读取延迟的关键，只是简单地切换活动线程组。为了使这种切换非常快，调度器管理的所有warp在寄存器文件中都有自己的寄存器。这里就会有个矛盾产生，shader需要越多的寄存器，就会给warp留下越少的空间，就会产生越少的warp，这时候在碰到内存延迟的时候就会只是等待，而没有可以运行的warp可以切换。</p></li>
<li><p>一旦warp完成了vertex-shader的所有指令，运算结果会被Viewport Transform模块处理，三角形会被裁剪然后准备栅格化，GPU会使用L1和L2缓存来进行vertex-shader和pixel-shader的数据通信。</p></li>
<li><p>接下来这些三角形将被分割，再分配给多个GPC，三角形的范围决定着它将被分配到哪个光栅引擎(raster engines)，每个raster engines覆盖了多个屏幕上的tile，这等于把三角形的渲染分配到多个tile上面。也就是像素阶段就把按三角形划分变成了按显示的像素划分了。</p></li>
<li><p>SM上的Attribute Setup保证了从vertex-shader来的数据经过插值后是pixel-shade是可读的。</p></li>
<li><p>GPC上的光栅引擎(raster engines)在它接收到的三角形上工作，来负责这些这些三角形的像素信息的生成（同时会处理裁剪Clipping、背面剔除和Early-Z剔除）。</p></li>
<li><p>32个像素线程将被分成一组，或者说8个2x2的像素块，这是在像素着色器上面的最小工作单元，在这个像素线程内，如果没有被三角形覆盖就会被遮掩，SM中的warp调度器会管理像素着色器的任务。</p></li>
<li><p>接下来的阶段就和vertex-shader中的逻辑步骤完全一样，但是变成了在像素着色器线程中执行。 由于不耗费任何性能可以获取一个像素内的值，导致锁步执行非常便利，所有的线程可以保证所有的指令可以在同一点。</p></li>
<li><p>最后一步，现在像素着色器已经完成了颜色的计算还有深度值的计算，在这个点上，我们必须考虑三角形的原始api顺序，然后才将数据移交给ROP(render output unit，渲染输入单元)，一个ROP内部有很多ROP单元，在ROP单元中处理深度测试，和framebuffer的混合，深度和颜色的设置必须是原子操作，否则两个不同的三角形在同一个像素点就会有冲突和错误。</p></li>
</ol>
]]></content>
      <categories>
        <category>GPU</category>
      </categories>
      <tags>
        <tag>pipeline</tag>
      </tags>
  </entry>
  <entry>
    <title>laptop-iGPU-dGPU-switch</title>
    <url>/2020/03/24/laptop-iGPU-dGPU-switch/</url>
    <content><![CDATA[<h2 id="optimus切换">Optimus切换</h2>
<p>2010年左右，英特尔发布了首批核芯显卡，将显示核心集成到CPU中，后来英伟达和AMD都推出了各自的新型智能显卡切换技术（英伟达的叫Optimus，AMD的叫Dynamic Switchable Graphics），解决了上一代切换显卡需要重启、或出现黑屏不顺畅的问题。 <a id="more"></a></p>
<h3 id="optiums的劣势">Optiums的劣势</h3>
<ul>
<li>使用Optimus无法禁用vsync。</li>
<li>由于独立显卡的图像要经过核芯显卡中转输出，因此独立显卡的性能发挥会受到核芯显卡的制约；而核芯显卡的显存与内存共享，独立显卡的性能发挥还会受到内存速度和带宽的影响。</li>
<li>一些老游戏和没做好适配的游戏在双显卡的笔记本上会出现BUG，这些游戏假设计算机只有一个GPU。当游戏开始时，它会搜索GPU，并首先找到Intel GPU。此后，游戏将只使用英特尔GPU。即使指定Nvidia GPU在Optimus中使用它，游戏仍然会在Intel GPU上运行。比如2008年发布的《侠盗猎车手4》，只能使用核芯显卡，即使右键手动设置使用独显运行也无效，要正常玩耍需要手动替换大神修改好的游戏文件才行。</li>
<li>双显卡智能切换技术需要操作系统的支持，也给其它一些应用场景带来了麻烦。Linux系统并不支持双显卡智能切换技术，导致独立显卡无法使用又不能进入闲置状态，造成空跑耗电和发热。（bumblebee等开源解决方案的稳定性不够高）。</li>
<li>具有可切换Intel / Nvidia显卡（Nvidia Optimus）的笔记本电脑将始终使用英特尔显卡。Optimus的工作方式是Nvidia GPU作为协处理器。如果指定游戏使用Nvidia GPU，它会在Nvidia GPU上呈现完整的帧。然后将完成帧传输到Intel GPU。然后英特尔GPU将其显示在屏幕上（全屏或窗口）。因此，即使游戏使用的是Nvidia GPU，英特尔GPU仍然可以正常工作。这就像让vsync始终打开一样，两个GPU充当两个帧缓冲区。如果在Optimus笔记本电脑上禁用Intel GPU，笔记本电脑将恢复到基本的VGA图形模式，直到重新安装英特尔驱动程序。</li>
</ul>
<h3 id="optiums无法禁用igpu的原因">Optiums无法禁用iGPU的原因</h3>
<p>凡是带有 Optimus 的笔记本是无法关闭 iGPU (intel 核心显卡) 的。因为这个设备的屏幕(LVDS/eDP)是来自于 iGPU 卡的 DAC(广义上的), 而且 HDMI/DisplayPort/VGA /DP over USB 3.1 按照标准方案都是来自 iGPU. 在 Windows 上控制 Optimus 设置的本质是, 让 3D 应用程序在选择 3D API 的执行设备(就比如 DX/OpenGL/OpenCL/Vulkan)的时候选择到偏好的设备上, 然后如果是让 dGPU 渲染, 那么渲染的 frame buffer 就会通过 PCIe 总线传输到 CPU, 交给窗口管理器, 窗口管理器交给 iGPU 进行最终输出. 这个过程会占用 PCIe 的带宽, 并引入延迟.Linux 上可以选择 PCIe 上回传画面的编码格式(jpeg, raw, png 等). 但是MacBook Pro 就是一个例外. MacBook Pro 的 eDP 和 DP(现在集成在 USB-C/Thunderbolt 中) 来自于 iGPU/dGPU, 系统会在纯 iGPU/dGPU 渲染 + iGPU 输出/dGPU 渲染输出 + iGPU 视频加速 这三个情况下切换, 所以集显能被关闭, 也能在独显启动时辅助视频解码. 这些特性都借助于 PCIe/DisplayPort 的分组交换。 <img src="https://s1.51cto.com/images/blog/201905/12/68cb4a5e53966a6514fbff7d7dad450c.png" alt="dp port" /> MacBook Pro 有两组视频源, 经过 TB 芯片后接到 eDP 屏幕, 然后 Thunderbolt HCI 接到 Thunderbolt PHY, 另外原生输出也可以直接通过 mDP 输出. <img src="https://s1.51cto.com/images/blog/201905/12/07745978233f39217cf39784031a7914.png" alt="Thunderbolt3-dp" /></p>
<h2 id="硬件双模切换">硬件双模切换</h2>
<h3 id="早期的显卡切换技术">早期的显卡切换技术</h3>
<p>核芯显卡尚未诞生的时候，笔记本上的集成显卡和独立显卡互不相容—二者只能启用其一，和台式机类似。给两个显卡都设计与屏幕连接的信号电路，在BIOS里添加一个切换功能，让用户可以选择开机时使用集成显卡还是独立显卡，实现了二者的共存。缺点是需要在BIOS里硬切换显示信号的输出路径，所以每次切换显卡都需要重启电脑，否则会导致黑屏。 <img src="https://s1.51cto.com/images/blog/201905/12/19121ae3773a51f2a1070a6354a7ce64.png" alt="mux" /></p>
<h3 id="mux-switch">MUX switch</h3>
<p>近几年游戏本的迅速发展给市场带来了转机，而游戏本的性能发挥十分重要，一些独显的专属特性（G-SYNC等）也要求笔记本的显示屏必须直连到独显才能使用，英特尔也逐渐放松并最终停止了对厂商的施压。因此我们重新看到了越来越多使用第三种整合方案的笔记本，比如几款高端准系统；刚发布新品不久的联想拯救者 Y7000、Y7000p和Y9000K也都采用了这种方案，并最高搭载了1T SSD的固态硬盘，其中Y7000和Y7000p也是近些年首次采用整合方案的中端游戏本。 为了解决optimus所带来的的种种问题，厂商又把MUX加了回来，但是这次MUX负责切换的并不是集显和独显了，而是optimus和独显。 MUX switch的好处是给用户一个选择的余地，既保留了独显输出的特性，又能在需要的时候切换回optimus以省电或者使用异构加成。缺点是需要像传统切换技术一样为核显和独显分别设计与屏幕连接的信号电路，测试也要分两种情况分别执行，增加了人力和物力成本，所以相关产品基本都不便宜。另外用户需要重启或者在BIOS中才能切换。</p>
<p>需要注意的是，显卡切换在不同的产品中会有不同的名称，比如： 对于蓝天： MSHybrid→optimus discrete→独显输出 对于alienware： PEG→独显输出 SG→optimus IGFX→关闭独显 关于MacBook： MacBook有MUX，支持纯集显/纯独显/集显输出独显渲染以及集显辅助视频解码。 和optimus不一样的是，这套体系是通过检测程序是否调用高性能API来决定最终使用的模式，另外在windows下只能使用独显。</p>
<h2 id="如何鉴别optimus与独显输出">如何鉴别optimus与独显输出</h2>
<ol type="1">
<li>看任务管理器/设备管理器，只有一个独显是独显输出模式，集显和独显同时出现则是optimus模式；</li>
<li>看鲁大师跑分，有异构分的一定是optimus模式，没有异构分的可能是optimus模式。</li>
<li>最后看bios选项，有切换选项的是支持多模切换，没有的是optimus/屏蔽集显。</li>
</ol>
]]></content>
      <categories>
        <category>GPU</category>
      </categories>
      <tags>
        <tag>optimus</tag>
      </tags>
  </entry>
  <entry>
    <title>vector-and-matrix-product</title>
    <url>/2020/03/24/vector-and-matrix-product/</url>
    <content><![CDATA[<h2 id="matrix">matrix</h2>
<p>glm中直接使用*作为<strong>哈达玛积</strong>（Hadamard product）的表示符号，结果为各个分量的乘积。一般表示符号为<span class="math inline">\(\odot\)</span>或<span class="math inline">\(\circ\)</span>。 Hadamard product 只是颜色积分公式的近似，只有在<span class="math inline">\(\rho(\lambda)\equiv\)</span>C（物体的光谱反射比在各波长上恒为一常数）时才成立。</p>
<p>Kronecker product（<strong>克罗内克积</strong>），也称为直积或张量积。是两个任意大小的矩阵间的运算，表示为<span class="math inline">\(\otimes\)</span>。克罗内克积是外积从向量到矩阵的推广，也是张量积在标准基下的矩阵表示。</p>
<h2 id="vector">vector</h2>
<p>glm使用dot表示<strong>点积</strong>，表示符号为<span class="math inline">\(\cdot\)</span> glm使用cross表示<strong>叉积</strong>，表示符号为<span class="math inline">\(\times\)</span></p>
]]></content>
      <categories>
        <category>math</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>edp-vs-lvds</title>
    <url>/2020/03/23/edp-vs-lvds/</url>
    <content><![CDATA[<p>EDP是电脑显示屏的一种通信接口，采用EDP显示接口的电脑分辨率会比LVDS接口的显示分辨率高，一般高清屏都是采用这种通信接口，也就是能实现您说的“宽视角”的功能。 <a id="more"></a></p>
<p>　　eDP和LVDS都是工控机中用来连接触摸屏或显示器的的视频信号接口。LVDS接口利用非常低的电压摆幅（约350mV）在两条PCB走线或一对平衡电缆上通过差分进行数据的传输，即低压差分信号传输。是为克服以TTL电平方式传输宽带高码率数据时功耗大、EMI电磁干扰大等缺点而研制的一种数字视频信号传输方式。工控机采用LVDS输出接口，可以使得信号在差分PCB线或平衡电缆上以几百Mbit/s的速率传输，因采用低压和低电流驱动方式，实现了低噪声和低功耗。</p>
<p>　　eDP接口是一种基于DisplayPort架构和协议的一种全数字化接口，可以用较简单的连接器以及较少的引脚来传递高分辨率信号，且能够实现多数据同时传输，故传输速率远高于LVDS。</p>
<pre><code>eDP接口特点：</code></pre>
<p>　　1、微封包结构，能够实现多数据的同时传输。</p>
<p>　　2、无需LVDS转换电路，电路简洁。</p>
<p>　　3、较小的EMI（电磁干扰），并具有强大的版权保护功能。</p>
<p>　　以分辨率为1920x1200、24bit彩色的液晶屏为例，若采用LVDS接口，则数据传输线需20对；若采用eDP接口，则只需要4对线。由此可见，eDP接口的优势相当明显，特别是在高清屏中。近年来，为了提高面板及处理器间的数据传输速度，在工控机及工业平板电脑中已大量采用eDP接口，eDP接口正迅速成为主流接口。</p>
<pre><code>　　eDP屏线和LVDS屏线的区别</code></pre>
<p>　　eDP屏线是指屏接口为0.3-0.5小间距焊接式扁平线，分为单通道与双通道。eDP屏线一般为2组绞线、3组绞线、5组绞线、8组绞。常见的eDP屏线为2组信号线（绞线）、3组信号线。</p>
<p>　　LVDS屏线分为标清线与高清线两种。LVDS屏线（高清线）屏接口为0.5间距双排，即JAE FIRE51P高清线。LVDS屏线（标准线）是指屏接口为1.0间距、1.25间距，端子为铆压式组装而成。常见有单八线、双八线。单八线大都为FIX-30P、DF141.25-30P，双八线大都为FIX-30Pin。</p>
<p>　　探讨一下你手上的X220/X230，或其他现有的笔电，升级更高分辨率面板的可能性。毕竟升级笔电内建屏幕，跟升级一般外接屏幕完全不同，很多情况并不是扁平电缆一插，就可以简单解决的事。</p>
<p>　　首先是物理限制，毕竟笔电的A壳（正面外壳）与B壳（屏幕边框）都是固定尺寸，A壳内部还得容纳扁平电缆、WLAN与WWAN天线、ThinkLight 小夜灯等等，内部空间利用已经到了极致，不可能安装尺寸更大，或是长宽比例不对的LCD面板。所以常被询问的LG LP129QE1-SPA1（12.9吋 15:10 2560&amp;TImes;1700），因为尺寸更大，且长宽比例不符合原厂面板的16:9，若要强行安装，屏幕上下边框会塞不进去，所以完全不能考虑。</p>
<p>　　第二个是BIOS限制，如果你的笔电屏幕是旧的LVDS接口，必须要有相应BIOS，才能正常驱动面板电源、输出正确分辨率等等。之前X60/X61更换 高分辨率AFFS面板，就是最好的事例，如果安装跟原厂屏幕分辨率相同的AFFS面板，只要另外找来扁平电缆转接头、加上屏幕边框小耳朵割掉，花上这两个 功夫即可。要是换装1440&amp;TImes;1050高分辨率AFFS面板，还得多出一道刷修改版BIOS的步骤。要是没有正确支持的BIOS，不同分辨率面板有可能无 法正常工作。</p>
<p>　　以X220/X230原厂搭配的1366&amp;TImes;768分辨率面板为例，只需要单通道LVDS扁平电缆作连接。若要支持1440&amp;TImes;900（含）以上高分辨率的 LCD面板，必须采用29条电线的双通道LVDS扁平电缆，其中有16条电线用于讯号传输，才有办法足够应付高分辨率的画面。（附注：18-bit=面板 6-bit色深x3、24-bit=面板8-bit色深x3。） <img src="https://s1.51cto.com/images/blog/201905/04/33aa10afa26f17689485d0c337c78785.png" /></p>
<pre><code>　　LVDS与eDP，阻隔屏幕升级的大石头</code></pre>
<p>　　第三个是讯号传输接口限制，目前笔电LCD面板的讯号传输方式，主要可分为LVDS与eDP（Embedded DisplayPort）两种接口，其中eDP是较新的技术，优点比传统LVDS接口还要多，而且Intel自从Haswell平台之后，芯片组就取消LVDS接口的支持，只保留eDP。如果你的笔电本身是采LVDS接口，当做内部屏幕讯号传输方式，则无法安装eDP接口的新面板，反之亦然。</p>
<p>　　另一块常被拿来讨论的面板，是LG LP125WF1-SPA1（12.5吋 16:9 1920×1080），因为它的尺寸与长宽比例，都跟X220/X230原厂配的一模一样，希望非常浓厚。它本身是Dell XPS 12 Ultrabook采用的面板，可是经过查询技术数据，这块面板是采用eDP接口，跟X220/X230提供的LVDS接口并不兼容，只好死了这条心。同样的，像现在14吋、16:9的规格，也渐渐有IPS且Full HD的新面板问世，但这些产品全都是eDP接口，无法兼容采用LVDS接口的T420/T430，只能说看得到却吃不到。 　　高分辨率屏幕，要双信道扁平电缆 　　第四个是扁平电缆限制，这边指的笔电主板，跟内建屏幕中间的传输扁平电缆。如果这条线材不对，即使前三个条件都符合了，还是不能支持更高分辨率的面板。根据技术规格，不论是LVDS或eDP接口，在传输更高分辨率的画面时，都必须采用讯号线更多的扁平电缆。这很合常理嘛，毕竟分辨率更高，数据量更大，当然要有更多条讯号线来传送。</p>
<p>　　像LVDS就分成单信道与双信道两种扁平电缆，前者负责传输影像讯号的电线只有8条，后者就有16条，单通道LVDS最高只支持到1366×768的分辨率，若要支持1440×900（含）以上高分辨率的LCD面板，就一定要双信道LVDS的扁平电缆。而eDP也 有分，分辨率1600×900以下，只用到2条影像讯号线，但如果要搭配Full HD高分辨率面板，得需要4条影像讯号线。问题是一般使用者，根本不知道笔电制造商，在机器里面是搭配单信道还是双信道的影像扁平电缆？这时候只能从同机 种，其他机型的规格来推测。如果同一台机器，官方有发售更高分辨率的机型，代表无痛升级的机会比较浓厚。不过厂商还是有在低分辨率机种，安装单信道扁平电 缆的可能性，毕竟可以省成本嘛，所以还是得做好另外换扁平电缆的心理准备。</p>
<p>　　X220与X230的LCD扁平电缆，都是内部只有19条电线的单通道LVDS，其中8条线用于讯号传输。从这里就可宣告X220与X230，没办法直接支持更高分辨率面板，就算解决扁平电缆问题，也必须再修改BIOS，才有办法正常驱动面板。</p>
<p><a href="http://www.elecfans.com/monijishu/jiekou_shizhong_PLL/599488_a.html" target="_blank" rel="noopener" class="uri">http://www.elecfans.com/monijishu/jiekou_shizhong_PLL/599488_a.html</a></p>
]]></content>
      <categories>
        <category>显示器</category>
      </categories>
      <tags>
        <tag>eDP</tag>
        <tag>LVDS</tag>
      </tags>
  </entry>
  <entry>
    <title>win10-vs2015-osgearth2.10</title>
    <url>/2020/03/23/win10-vs2015-osgearth2-10/</url>
    <content><![CDATA[<h2 id="osg编译">OSG编译</h2>
<h3 id="源码或预编译库下载">源码或预编译库下载</h3>
<p>OSG版本3.6.3； CMake版本3.12.1-x64； Geos版本：3.7.1； GDAL版本：2.3.1； 数据包由官网下载； 官网上还提供其他vs2015环境下OSG编译依赖的第三方库所用的CMake编译脚本，其地址为<a href="https://github.com/bjornblissing/osg-3rdparty-cmake" target="_blank" rel="noopener" class="uri">https://github.com/bjornblissing/osg-3rdparty-cmake</a> 同时该页面提供由AppVeyor所预编译好的vs2015和vs2017的库文件下载。 <a id="more"></a></p>
<h3 id="文件目录">文件目录</h3>
<p>D:.3 D:\3rd-v140-x64：第三方依赖库 D:-Data：数据包解压后放于此。</p>
<h3 id="cmake配置">CMake配置</h3>
<p>在configure后，选择列表项ACTUAL_3RDPARTY_DIR将值设置为D:/OSG/3rd-v140-x64，BUILD_OSG_EXAMPLES值设置为ON，设置CMAKE_INSTALL_PREFIX为最后的编译好的库文件复制安装路径。</p>
<h3 id="vs2015编译">vs2015编译</h3>
<p>打开OpenSceneGraph.sln，生成All_BUILD，可只选择Release版本。</p>
<h3 id="设置环境变量">设置环境变量</h3>
<p>添加系统变量：OSG_FILE_PATH，值为D:-Data；在PATH变量中添加：D:.3。配置完成后，可在命令行输入osgversion测试。</p>
<h2 id="编译安装osgearth依赖项">编译安装OSGEarth依赖项</h2>
<p>编译GEOS、GDAL、CURL、ZLIB等；</p>
<h2 id="编译安装osgearth">编译安装OSGEarth</h2>
<p>在CMake中指定OSG_DIR为D:.3，指定THIRD_PARTY_DIR为D:/OSG/3rd-v140-x64；依次对CURL、GDAL、GEOS、ZLIB进行处理（若系统环境变量中设置了相关库name和value，则会自动查找配置），然后勾上Advanced。</p>
]]></content>
      <categories>
        <category>osgearth</category>
      </categories>
  </entry>
  <entry>
    <title>Tesla/Quadro-vs-GeForce</title>
    <url>/2020/03/22/Tesla-Quadro-vs-GeForce/</url>
    <content><![CDATA[<p>该资源由Microway根据NVIDIA和可信媒体来源提供的数据编写。 所有NVIDIA GPU都支持通用计算（GPGPU），但并非所有GPU都提供相同的性能或支持相同的功能。GeForce GPU的消费者产品线（特别是GTX Titan）可能对那些运行GPU加速应用程序的人很有吸引力。但是，记住产品之间的差异是明智的。专业的Tesla和Quadro GPU有许多功能。 <a id="more"></a></p>
<h3 id="fp64-64位双精度浮点计算">FP64 64位（双精度）浮点计算</h3>
<p>许多应用需要更高精度的数学计算。在这些应用程序中，数据由两倍大的值表示（使用64位二进制位而不是32位）。这些较大的值称为双精度（64位）。不太准确的值称为单精度（32位）。虽然几乎所有NVIDIA GPU产品都支持单精度和双精度计算，但在大多数消费级GeForce GPU上，双精度值的性能要低得多。以下是GeForce和Tesla / Quadro GPU之间双精度浮点计算性能的比较：</p>
<table>
<thead>
<tr class="header">
<th>NVIDIA GPU模型</th>
<th>双精度（64位）浮点性能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>GeForce GTX Titan X Maxwell</td>
<td>高达0.206 TFLOPS</td>
</tr>
<tr class="even">
<td>GeForce GTX 1080 Ti</td>
<td>高达0.355 TFLOPS</td>
</tr>
<tr class="odd">
<td>GeForce Titan Xp</td>
<td>高达0.380 TFLOPS</td>
</tr>
<tr class="even">
<td>GeForce Titan V.</td>
<td>高达6.875 TFLOPS</td>
</tr>
<tr class="odd">
<td>GeForce RTX 2080 Ti</td>
<td>估计~0.44 TFLOPS</td>
</tr>
<tr class="even">
<td>特斯拉K80</td>
<td>1.87+ TFLOPS</td>
</tr>
<tr class="odd">
<td>特斯拉P100 *</td>
<td>4.7~5.3 TFLOPS</td>
</tr>
<tr class="even">
<td>Quadro GP100</td>
<td>5.2 TFLOPS</td>
</tr>
<tr class="odd">
<td>特斯拉V100 *</td>
<td>7~7.8 TFLOPS</td>
</tr>
<tr class="even">
<td>Quadro GV100</td>
<td>7.4 TFLOPS</td>
</tr>
<tr class="odd">
<td>Quadro RTX 6000和8000</td>
<td>~0.5 TFLOPS</td>
</tr>
<tr class="even">
<td>特斯拉T4</td>
<td>估计~0.25 TFLOPS</td>
</tr>
</tbody>
</table>
<p>*确切的值取决于PCI-Express或SXM2 SKU</p>
<h3 id="fp16-16位半精度浮点计算">FP16 16位（半精度）浮点计算</h3>
<p>一些应用程序不需要高精度（例如，神经网络训练/推理和某些HPC使用）。在“Pascal”GPU中 引入了对半精度FP16操作的支持。这是以前深度学习/人工智能计算的标准; 但是，深度学习工作负载已转移到更复杂的操作（请参阅下面的TensorCores）。尽管所有NVIDIA“Pascal”和后来的GPU都支持FP16，但在许多以游戏为中心的GPU上，性能显着降低。以下是GeForce和Tesla / Quadro GPU之间半精度浮点计算性能的比较：</p>
<table>
<thead>
<tr class="header">
<th>NVIDIA GPU模型</th>
<th>半精度（16位）浮点性能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>GeForce GTX Titan X Maxwell</td>
<td>N / A</td>
</tr>
<tr class="even">
<td>GeForce GTX 1080 Ti</td>
<td>小于0.177 TFLOPS</td>
</tr>
<tr class="odd">
<td>GeForce Titan Xp</td>
<td>小于0.190 TFLOPS</td>
</tr>
<tr class="even">
<td>GeForce Titan V.</td>
<td>~27.5 TFLOPS</td>
</tr>
<tr class="odd">
<td>GeForce RTX 2080 Ti</td>
<td>28.5 TFLOPS</td>
</tr>
<tr class="even">
<td>特斯拉K80</td>
<td>N / A</td>
</tr>
<tr class="odd">
<td>特斯拉P100 *</td>
<td>18.7~21.2 TFLOPS *</td>
</tr>
<tr class="even">
<td>Quadro GP100</td>
<td>20.7 TFLOPS</td>
</tr>
<tr class="odd">
<td>特斯拉V100 *</td>
<td>28~31.4 TFLOPS *</td>
</tr>
<tr class="even">
<td>Quadro GV100</td>
<td>29.6 TFLOPS</td>
</tr>
<tr class="odd">
<td>Quadro RTX 6000和8000</td>
<td>32.6 TFLOPS</td>
</tr>
<tr class="even">
<td>特斯拉T4</td>
<td>16.2 TFLOPS</td>
</tr>
</tbody>
</table>
<p>*确切的值取决于PCI-Express或SXM2 SKU</p>
<h3 id="tensorflops和深度学习表现">TensorFLOPS和深度学习表现</h3>
<p>一个新的专业的Tensor Core单元与“Volta”GPU一起推出。它将两个FP16单元（转换为全精度产品）与FP32累加运算相结合 - 这是深度学习训练计算中使用的精确操作。NVIDIA现在通过一种新的深度学习性能指标测量Tensor Core的GPU：一个名为TensorTFLOPS的新单元。</p>
<p>Tensor Core仅适用于“Volta”GPU或更新版本。作为参考，如果没有TensorFLOPS值，我们将以任何精度提供最大的已知深度学习性能。我们认为，比较不同精度之间的表现是非常差的科学方法; 然而，我们也认识到希望在不同代GPU的深度学习性能之间至少看到一个数量级的性能比较。</p>
<table>
<thead>
<tr class="header">
<th>NVIDIA GPU模型</th>
<th>TensorFLOPS （或最大DL性能）</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>GeForce GTX Titan X Maxwell</td>
<td>N / A TensorTFLOPS, ~6.1 TFLOPS FP32</td>
</tr>
<tr class="even">
<td>GeForce GTX 1080 Ti</td>
<td>N / A TensorTFLOPS, ~11.3 TFLOPS FP32</td>
</tr>
<tr class="odd">
<td>GeForce Titan Xp</td>
<td>N / A TensorTFLOPS, ~12.1 TFLOPS FP32</td>
</tr>
<tr class="even">
<td>GeForce Titan V. 110</td>
<td>TensorTFLOPS</td>
</tr>
<tr class="odd">
<td>GeForce RTX 2080 Ti</td>
<td>56.9 TensorTFLOPS 455.4 TOPS, INT4用于推理</td>
</tr>
<tr class="even">
<td>特斯拉K80</td>
<td>N / A TensorTFLOPS ,5.6 TFLOPS FP32</td>
</tr>
<tr class="odd">
<td>特斯拉P100 *</td>
<td>N / A TensorTFLOPS ,18.7~21.2 TFLOPS FP16</td>
</tr>
<tr class="even">
<td>Quadro GP100</td>
<td>N / A TensorTFLOPS ,20.7 TFLOPS FP16</td>
</tr>
<tr class="odd">
<td>特斯拉V100 *</td>
<td>112~125 TensorTFLOPS</td>
</tr>
<tr class="even">
<td>Quadro GV100</td>
<td>118.5 TensorTFLOPS</td>
</tr>
<tr class="odd">
<td>Quadro RTX 6000和8000</td>
<td>130.5 TensorTFLOPS 522 TOPS, INT4用于推理</td>
</tr>
<tr class="even">
<td>特斯拉T4</td>
<td>65 TensorTFLOPS 260 TOPS, INT4用于推理</td>
</tr>
</tbody>
</table>
<p>*确切的值取决于PCI-Express或SXM2 SKU</p>
<h3 id="错误检测和纠正">错误检测和纠正</h3>
<p>在运行计算机游戏的GPU上，一个存储器错误通常不会引起任何问题（例如，一帧的一个像素颜色可能不正确）。用户甚至不太可能意识到这个问题。但是，技术计算应用程序依赖于GPU返回的数据的准确性。对于某些应用程序，单个错误可能导致严重且明显的错误。对于其他人来说，单比特位错误可能不容易检测（返回看似合理的错误结果）。Titan GPU不包括纠错或错误检测功能。如果发生错误，GPU和系统都不会警告用户错误。用户可以检测错误（它们是否会导致应用程序崩溃，明显错误的数据，或者是不明显的错误数据）。这些问题并不少见 - 我们的技术人员经常在消费者游戏GPU上遇到内存错误。NVIDIA Tesla GPU能够纠正单比特错误并检测和警告双比特错误。在最新的Tesla V100，Tesla T4，Tesla P100和Quadro GV100 / GP100 GPU上，ECC支持包含在主HBM2内存中，以及寄存器文件，共享内存，L1缓存和L2缓存中。</p>
<h3 id="保修和最终用户许可协议">保修和最终用户许可协议</h3>
<p>NVIDIA对GeForce GPU产品的保修明确规定GeForce产品不适合安装在服务器上。在服务器系统中运行GeForce GPU将使GPU的保修失效，用户自担风险。来自NVIDIA的制造商保修网站：</p>
<p>保证产品仅供消费者最终用户使用，不适用于数据中心使用和/或GPU集群商业部署（“企业使用”）。使用保证产品用于企业使用将使本保修失效。</p>
<p>NVIDIA GeForce产品驱动程序软件附带的许可协议声明：</p>
<p>禁止数据中心部署。除了允许数据中心中的区块链处理之外，该软件未获得数据中心部署许可。</p>
<h3 id="gpu内存性能">GPU内存性能</h3>
<p>计算密集型应用程序需要高性能计算单元，但快速访问数据也很关键。对于许多HPC应用程序，除非内存性能也得到改善，否则计算性能的提高无济于事。因此，Tesla GPU提供比GeForce GPU更好的实际性能：</p>
<table>
<thead>
<tr class="header">
<th>NVIDIA GPU模型</th>
<th>GPU内存带宽</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>GeForce GTX Titan X Maxwell</td>
<td>336 GB / s</td>
</tr>
<tr class="even">
<td>GeForce GTX 1080 Ti</td>
<td>484 GB / s</td>
</tr>
<tr class="odd">
<td>GeForce Titan Xp</td>
<td>548 GB / s</td>
</tr>
<tr class="even">
<td>GeForce Titan V.</td>
<td>653 GB / s</td>
</tr>
<tr class="odd">
<td>GeForce RTX 2080 Ti</td>
<td>616 GB / s</td>
</tr>
<tr class="even">
<td>特斯拉K80</td>
<td>480 GB / s</td>
</tr>
<tr class="odd">
<td>特斯拉P40</td>
<td>346 GB / s</td>
</tr>
<tr class="even">
<td>特斯拉P100 12GB</td>
<td>549 GB / s</td>
</tr>
<tr class="odd">
<td>特斯拉P100 16GB</td>
<td>732 GB / s</td>
</tr>
<tr class="even">
<td>Quadro GP100</td>
<td>717 GB / s</td>
</tr>
<tr class="odd">
<td>特斯拉V100 16GB / 32GB</td>
<td>900 GB / s</td>
</tr>
<tr class="even">
<td>Quadro GV100</td>
<td>870 GB / s</td>
</tr>
<tr class="odd">
<td>Quadro RTX 6000和8000</td>
<td>624 GB / s</td>
</tr>
<tr class="even">
<td>特斯拉T4</td>
<td>320 GB / s</td>
</tr>
</tbody>
</table>
<h3 id="gpu内存大小">GPU内存大小</h3>
<p>通常，系统运行的内存越多，运行的速度就越快。对于某些HPC应用程序，除非有足够的内存，否则甚至无法执行单次运行。对于其他人来说，除非有足够的内存，否则结果的质量和保真度会降低。Tesla GPU提供的内存是GeForce GPU的两倍：</p>
<table>
<thead>
<tr class="header">
<th>GPU 模型</th>
<th>内存容量</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>GeForce GTX 1080 Ti</td>
<td>11GB</td>
</tr>
<tr class="even">
<td>GeForce Titan Xp</td>
<td>12GB</td>
</tr>
<tr class="odd">
<td>GeForce GTX Titan V.</td>
<td>12GB</td>
</tr>
<tr class="even">
<td>GeForce RTX 2080 Ti</td>
<td>11GB</td>
</tr>
<tr class="odd">
<td>特斯拉K80</td>
<td>24GB</td>
</tr>
<tr class="even">
<td>特斯拉P40</td>
<td>24GB</td>
</tr>
<tr class="odd">
<td>特斯拉P100</td>
<td>12GB或16GB *</td>
</tr>
<tr class="even">
<td>Quadro GP100</td>
<td>16GB *</td>
</tr>
<tr class="odd">
<td>特斯拉V100</td>
<td>16GB或32GB *</td>
</tr>
<tr class="even">
<td>Quadro GV100</td>
<td>32GB *</td>
</tr>
<tr class="odd">
<td>Quadro RTX 6000</td>
<td>24GB *</td>
</tr>
<tr class="even">
<td>Quadro RTX 8000</td>
<td>48GB *</td>
</tr>
<tr class="odd">
<td>特斯拉T4</td>
<td>16GB *</td>
</tr>
</tbody>
</table>
<p>*请注意，特斯拉/ Quadro统一内存允许GPU共享彼此的内存以加载更大的数据集</p>
<h3 id="pci-e与nvlink---设备到主机和设备到设备的吞吐量">PCI-E与NVLink - 设备到主机和设备到设备的吞吐量</h3>
<p>最大的潜在瓶颈之一是等待数据传输到GPU。当多个GPU并行运行时，存在额外的瓶颈。更快的数据传输直接导致更快的应用程序性能。GeForce GPU通过PCI-Express连接，其理论峰值吞吐量为16GB / s。配备NVLink的NVIDIA Tesla / Quadro GPU能够更快地实现连接。NVIDIA的“Pascal”中的NVLink 允许每个GPU以高达80GB / s（160GB / s双向）的速度进行通信。NVIDIA的“Volta”系列中的NVLink 2.0 允许每个GPU以高达150GB / s（300GB / s双向）的速度进行通信。GPU之间以及支持的OpenPOWER平台上的CPU和GPU之间支持NVLink连接。</p>
<h3 id="应用软件支持">应用软件支持</h3>
<p>虽然某些软件程序能够在支持CUDA的任何GPU上运行，但其他软件程序则针对专业GPU系列进行了设计和优化。大多数专业软件包仅正式支持NVIDIA Tesla和Quadro GPU。使用GeForce GPU是可能的，但软件供应商不会支持。在其他情况下，在GeForce GPU（例如，Schrödinger，LLC的软件产品）上启动时，应用程序根本不起作用。</p>
<h3 id="操作系统支持">操作系统支持</h3>
<p>虽然NVIDIA的GPU驱动程序非常灵活，但是没有适用于Windows Server操作系统的GeForce驱动程序。GeForce GPU仅在Windows 7，Windows 8和Windows 10上受支持。使用Windows Server的组应该使用NVIDIA专业的Tesla和Quadro GPU产品。另一方面，Linux驱动程序支持所有NVIDIA GPU。</p>
<h3 id="产品生命周期">产品生命周期</h3>
<p>由于消费者GPU市场的性质，GeForce产品的生命周期相对较短（产品发布和生产结束之间通常不超过一年）。需要更长产品寿命的项目（例如购买后3年以上可能需要更换部件的项目）应使用专业GPU。NVIDIA专业的Tesla和Quadro GPU产品具有延长的生命周期和制造商的长期支持（包括产品生命终结的通知以及停止生产前的最后购买机会）。此外，专业GPU在生产过程中经历了更彻底的测试和验证过程。</p>
<h3 id="电源效率">电源效率</h3>
<p>GeForce GPU适用于消费者游戏，通常不是为提高电源效率而设计的。相比之下，Tesla GPU专为大规模部署而设计，其中功率效率非常重要。这使得Tesla GPU成为大型安装的更好选择。例如，GeForce GTX Titan X非常适合桌面深度学习工作负载。在服务器部署中，Tesla P40 GPU提供匹配的性能和双倍的内存容量。然而，当并排放置时，特斯拉消耗更少的电力并产生更少的热量。</p>
<h3 id="dma引擎">DMA引擎</h3>
<p>GPU的直接内存访问（DMA）引擎允许在系统内存和GPU内存之间进行快速数据传输。由于此类传输是任何实际应用程序的一部分，因此性能对GPU加速至关重要。缓慢的传输导致GPU核心处于空闲状态，直到数据到达GPU内存。同样，慢速返回会导致CPU等待，直到GPU完成返回结果。</p>
<p>GeForce产品具有单个DMA引擎*，可以一次传输一个方向的数据。如果正在将数据上载到GPU，则在上载完成之前，无法返回由GPU计算的任何结果。同样，从GPU返回的结果将阻止需要上传到GPU的任何新数据。Tesla GPU产品采用双DMA引擎来缓解这一瓶颈。数据可以同时传输到GPU和GPU中。</p>
<p>*一个GeForce GPU型号，GeForce GTX Titan X，具有双DMA引擎</p>
<h3 id="gpu直接rdma">GPU直接RDMA</h3>
<p>NVIDIA的GPU-Direct技术可以极大地提高GPU之间的数据传输速度。各种功能由GPU-Direct保护，但RDMA功能可带来最大的性能提升。传统上，在群集的GPU之间发送数据需要3个内存副本（一次到GPU的系统内存，一次到CPU的系统内存，一次到InfiniBand驱动程序的内存）。GPU Direct RDMA删除系统内存副本，允许GPU直接通过InfiniBand将数据发送到远程系统。实际上，对于小型MPI消息大小，这减少延迟高达67％，带宽增加430％[ 1 ]。在CUDA 8.0版中，NVIDIA推出了GPU Direct RDMA ASYNC，允许GPU在不与CPU进行任何交互的情况下启动RDMA传输。</p>
<p>GeForce GPU不支持GPU-Direct RDMA。虽然MPI调用仍将成功返回，但传输将通过标准内存复制路径执行。GeForce卡支持的唯一GPU-Direct形式是GPU Direct Peer-to-Peer（P2P）。这允许在单个计算机内进行快速传输，但对于跨多个服务器/计算节点运行的应用程序不执行任何操作。Tesla GPU完全支持GPU Direct RDMA和各种其他GPU Direct功能。它们是这些功能的主要目标，因此在该领域经过最多的测试和使用。</p>
<h3 id="hyper-q">Hyper-Q</h3>
<p>用于MPI和CUDA Streams的Hyper-Q代理允许多个CPU线程或进程在单个GPU上启动工作。这对于使用MPI编写的现有并行应用程序尤为重要，因为这些代码旨在利用多个CPU内核。允许GPU接受系统上运行的每个MPI线程的工作可以提供潜在的显着性能提升。它还可以减少将GPU加速添加到现有应用程序所需的源代码重新架构量。但是，GeForce GPU支持的唯一Hyper-Q形式是CUDA Streams的Hyper-Q。这允许GeForce有效地接受并运行来自不同CPU核心的并行计算，但是跨多台计算机运行的应用程序将无法有效地在GPU上启动工作。</p>
<h3 id="gpu健康监控和管理功能">GPU健康监控和管理功能</h3>
<p>许多运行状况监控和GPU管理功能（对于维护多个GPU系统至关重要）仅在专业的Tesla GPU上得到支持。GeForce GPU不支持的健康功能包括：</p>
<ul>
<li>NVML/nvidia-smi用于监视和管理每个GPU的状态和功能。这使得许多第三方应用程序和工具（如Ganglia）支持GPU。Perl和Python绑定也可用。</li>
<li>OOB（通过IPMI进行带外监控）允许系统监控GPU运行状况，调整风扇速度以适当冷却设备并在发现问题时发送警报</li>
<li>InfoROM（持久配置和状态数据）为系统提供有关每个GPU的附加数据</li>
<li>NVHealthmon实用程序为集群管理员提供了即用型GPU健康状态工具</li>
<li>TCC允许将GPU专门设置为仅显示或仅计算模式</li>
<li>ECC（内存错误检测和纠正） 群集工具依赖于NVIDIA NVML提供的功能。大约60％的功能在GeForce上不可用 - 该表提供了对Tesla和GeForce GPU支持的NVML功能的更详细比较：</li>
</ul>
<table>
<thead>
<tr class="header">
<th>特征</th>
<th>Tesla</th>
<th>Geforce</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>产品名称</td>
<td>是</td>
<td>是</td>
</tr>
<tr class="even">
<td>显示GPU计数</td>
<td>是</td>
<td>是</td>
</tr>
<tr class="odd">
<td>PCI-Express生成（例如，2.0 vs 3.0）</td>
<td>是</td>
<td>-</td>
</tr>
<tr class="even">
<td>PCI-Express链接宽度（例如，x4，x8，x16）</td>
<td>是</td>
<td>-</td>
</tr>
<tr class="odd">
<td>当前风扇速度</td>
<td>是</td>
<td>是</td>
</tr>
<tr class="even">
<td>当前温度</td>
<td>是</td>
<td>是*</td>
</tr>
<tr class="odd">
<td>目前的表现状况</td>
<td>是</td>
<td>-</td>
</tr>
<tr class="even">
<td>时钟节流状态</td>
<td>是</td>
<td>-</td>
</tr>
<tr class="odd">
<td>当前GPU使用率（百分比）</td>
<td>是</td>
<td>-</td>
</tr>
<tr class="even">
<td>当前内存使用率（百分比）</td>
<td>是</td>
<td>是</td>
</tr>
<tr class="odd">
<td>GPU提升能力</td>
<td>是</td>
<td>是^</td>
</tr>
<tr class="even">
<td>ECC错误检测/更正支持</td>
<td>是</td>
<td>-</td>
</tr>
<tr class="odd">
<td>列出已退休的页面</td>
<td>是</td>
<td>-</td>
</tr>
<tr class="even">
<td>目前的权力抽奖</td>
<td>是</td>
<td>-</td>
</tr>
<tr class="odd">
<td>设置功率限制</td>
<td>是</td>
<td>-</td>
</tr>
<tr class="even">
<td>当前GPU时钟速度</td>
<td>是</td>
<td>-</td>
</tr>
<tr class="odd">
<td>当前内存时钟速度</td>
<td>是</td>
<td>-</td>
</tr>
<tr class="even">
<td>显示可用的时钟速度</td>
<td>是</td>
<td>-</td>
</tr>
<tr class="odd">
<td>显示可用的内存速度</td>
<td>是</td>
<td>-</td>
</tr>
<tr class="even">
<td>设置GPU提升速度（核心时钟和内存时钟）</td>
<td>是</td>
<td>-</td>
</tr>
<tr class="odd">
<td>显示当前计算过程</td>
<td>是</td>
<td>-</td>
</tr>
<tr class="even">
<td>卡序列号</td>
<td>是</td>
<td>-</td>
</tr>
<tr class="odd">
<td>InfoROM图像和对象</td>
<td>是</td>
<td>-</td>
</tr>
<tr class="even">
<td>会计能力（每个流程的资源使用）</td>
<td>是</td>
<td>-</td>
</tr>
<tr class="odd">
<td>PCI-Express ID</td>
<td>是</td>
<td>是</td>
</tr>
<tr class="even">
<td>NVIDIA驱动程序版本</td>
<td>是</td>
<td>是</td>
</tr>
<tr class="odd">
<td>NVIDIA VBIOS版本</td>
<td>是</td>
<td>是</td>
</tr>
</tbody>
</table>
<p>*系统平台无法读取温度，这意味着无法调整风扇速度。</p>
<p>^双精度计算期间禁用GPU Boost。此外，在某些情况下，GeForce时钟速度将自动降低。</p>
<h3 id="gpu加速">GPU加速</h3>
<p>所有最新的NVIDIA GPU产品都支持GPU Boost，但它们的实现方式因预期的使用场景而异。GeForce卡专为交互式桌面使用和游戏而设计。Tesla GPU专为密集，恒定数量的运算而设计，稳定性和可靠性非常高。鉴于这两个用例之间的差异，GPU Boost在特斯拉上的功能与在GeForce上的不同。</p>
<h4 id="gpu如何在geforce上运行">GPU如何在GeForce上运行</h4>
<p>在Geforce的情况下，显卡会根据GPU的温度自动确定时钟速度和电压。温度是适当的自变量，因为发热会影响风扇速度。对于图形较少的游戏或一般桌面使用，最终用户可以享受更安静的计算体验。然而，在玩需要严格GPU计算的游戏时，GPU Boost会自动提高电压和时钟速度（也会产生更多噪音）。</p>
<h4 id="gpu如何在特斯拉上工作">GPU如何在特斯拉上工作</h4>
<p>另一方面，特斯拉的GPU加速水平也可以通过电压和温度来确定，但不总是以这种方式运行。</p>
<p>如果愿意，可以由系统管理员或计算用户指定增强 - 可以将所需的时钟速度设置为特定频率。除了将时钟速度浮动到各种电平之外，可以静态地保持期望的时钟速度，除非达到功耗阈值（TDP）。这是一个重要的考虑因素，因为HPC环境中的加速器通常需要彼此同步。特斯拉GPU增强的可选确定性方面允许系统管理员确定最佳时钟速度并将其锁定在所有GPU中。</p>
<p>对于需要额外性能和确定性的应用，可以将最新的Tesla GPU设置为同步升压组内的自动升压。启用组启用自动增强功能后，每组GPU将在净空允许时提高时钟速度。该小组将保持时钟彼此同步，以确保整个组的匹配性能。可以在NVIDIA DCGM工具中设置组。</p>
<p><a href="https://www.microway.com/knowledge-center-articles/comparison-of-nvidia-geforce-gpus-and-nvidia-tesla-gpus/" target="_blank" rel="noopener" class="uri">https://www.microway.com/knowledge-center-articles/comparison-of-nvidia-geforce-gpus-and-nvidia-tesla-gpus/</a></p>
]]></content>
      <categories>
        <category>GPU</category>
      </categories>
  </entry>
  <entry>
    <title>cesium-offline</title>
    <url>/2020/03/22/cesium-offline/</url>
    <content><![CDATA[<h3 id="数据源">数据源</h3>
<ol type="1">
<li>卫星影像纹理。使用sxearth等软件以tms格式从已有的网络地图服务商下载存储。</li>
<li>DEM数据。网络公开可下载全球数据有：SRTMV4.1、AW3D30、TanDEM-X等。 <a id="more"></a></li>
</ol>
<h3 id="dem数据预处理">DEM数据预处理</h3>
<p>Cesium支持两种格式的地形：一种是quantized-mesh格式的数据，另一种是基于heightmap的DEM。获得的DEM数据源一般为tiff格式，需要进行转换才能由Cesium处理。可用的转换工具有cesiumlab和cesium-terrain-builder，ctb工具可以处理heightmap格式数据，其更新版本<a href="https://github.com/ahuarte47/cesium-terrain-builder/tree/master-quantized-mesh" target="_blank" rel="noopener">ctb-qmesh</a>可以处理quantized-mesh格式数据。</p>
<ol type="1">
<li>ctb工具的编译。</li>
<li>使用GIS工具软件（GDAL、QGIS、arcMap等）把下载的tiff格式地形文件中的坐标转为WGS84，再将文件中采样中高程数据的nodata异常值使用0或者插值等进行填充。</li>
<li>运行ctb-tile.exe将下载的tiff格式地形文件生成为.terrain瓦片文件。</li>
<li>运行ctb-tile，添加参数-l生成供cesium使用的地图元数据LAYER.JSON。</li>
</ol>
<h3 id="cesium配置">cesium配置</h3>
<ol type="1">
<li>下载解压cesium，如果使用node提供服务，可直接运行根目录的server.js文件。若使用其他web服务器如nginx，则将解压目录中的build/cesium文件夹复制到nginx根目录，配置nginx.conf文件，添加以下内容: <figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line">   <span class="section">server</span> &#123;</span><br><span class="line"><span class="attribute">listen</span>	<span class="number">8001</span>;</span><br><span class="line"><span class="attribute">server_name</span>	localhost;</span><br><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line"><span class="attribute">if</span> (<span class="variable">$request_method</span> = <span class="string">'OPTIONS'</span>) &#123;</span><br><span class="line">	<span class="attribute">add_header</span> <span class="string">'Access-Control-Allow-Origin'</span> <span class="string">'*'</span>;</span><br><span class="line">	<span class="attribute">add_header</span> <span class="string">'Access-Control-Allow-Methods'</span> <span class="string">'GET, POST, OPTIONS'</span>;</span><br><span class="line">	<span class="comment">#</span></span><br><span class="line">	<span class="comment"># Custom headers and headers various browsers *should* be OK with but aren't</span></span><br><span class="line">	<span class="comment">#</span></span><br><span class="line">	<span class="attribute">add_header</span> <span class="string">'Access-Control-Allow-Headers'</span> <span class="string">'DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range'</span>;</span><br><span class="line">	<span class="comment">#</span></span><br><span class="line">	<span class="comment"># Tell client that this pre-flight info is valid for 20 days</span></span><br><span class="line">	<span class="comment">#</span></span><br><span class="line">	<span class="attribute">add_header</span> <span class="string">'Access-Control-Max-Age'</span> <span class="number">1728000</span>;</span><br><span class="line">	<span class="attribute">add_header</span> <span class="string">'Content-Type'</span> <span class="string">'text/plain; charset=utf-8'</span>;</span><br><span class="line">	<span class="attribute">add_header</span> <span class="string">'Content-Length'</span> <span class="number">0</span>;</span><br><span class="line">	<span class="attribute">return</span> <span class="number">204</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="attribute">if</span> (<span class="variable">$request_method</span> = <span class="string">'POST'</span>) &#123;</span><br><span class="line">	<span class="attribute">add_header</span> <span class="string">'Access-Control-Allow-Origin'</span> <span class="string">'*'</span>;</span><br><span class="line">	<span class="attribute">add_header</span> <span class="string">'Access-Control-Allow-Methods'</span> <span class="string">'GET, POST, OPTIONS'</span>;</span><br><span class="line">	<span class="attribute">add_header</span> <span class="string">'Access-Control-Allow-Headers'</span> <span class="string">'DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range'</span>;</span><br><span class="line">	<span class="attribute">add_header</span> <span class="string">'Access-Control-Expose-Headers'</span> <span class="string">'Content-Length,Content-Range'</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="attribute">if</span> (<span class="variable">$request_method</span> = <span class="string">'GET'</span>) &#123;</span><br><span class="line">	<span class="attribute">add_header</span> <span class="string">'Access-Control-Allow-Origin'</span> <span class="string">'*'</span>;</span><br><span class="line">	<span class="attribute">add_header</span> <span class="string">'Access-Control-Allow-Methods'</span> <span class="string">'GET, POST, OPTIONS'</span>;</span><br><span class="line">	<span class="attribute">add_header</span> <span class="string">'Access-Control-Allow-Headers'</span> <span class="string">'DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range'</span>;</span><br><span class="line">	<span class="attribute">add_header</span> <span class="string">'Access-Control-Expose-Headers'</span> <span class="string">'Content-Length,Content-Range'</span>;</span><br><span class="line">     &#125;</span><br><span class="line">	<span class="attribute">root</span>	F:/nginxhtml;</span><br><span class="line">	<span class="attribute">index</span>	index.html index.htm;</span><br><span class="line">   	&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure> 其中条件语句目的是为了解决cors资源共享问题。</li>
<li>将影像及处理好的地形文件复制到nginx根目录，编辑cesium示例中的helloworld.html文件，添加如下内容： <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Cesium.Ion.defaultAccessToken = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> xaterrain = <span class="keyword">new</span> Cesium.CesiumTerrainProvider(&#123;</span><br><span class="line">  url: <span class="string">'http://localhost:8001/ql-terrain'</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> tms = Cesium.createTileMapServiceImageryProvider(&#123;</span><br><span class="line">  url: <span class="string">'http://localhost:8001/ql-google-sat'</span>,</span><br><span class="line">  fileExtension: <span class="string">'jpg'</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> viewer = <span class="keyword">new</span> Cesium.Viewer(<span class="string">'cesiumContainer'</span>, &#123;</span><br><span class="line">  geocoder: <span class="literal">false</span>,</span><br><span class="line">  sceneModePicker: <span class="literal">false</span>,</span><br><span class="line">  navigationHelpButton: <span class="literal">false</span>,</span><br><span class="line">  homeButton: <span class="literal">false</span>,</span><br><span class="line">  timeline: <span class="literal">false</span>,</span><br><span class="line">  animation: <span class="literal">false</span>,</span><br><span class="line">  baseLayerPicker: <span class="literal">false</span>,</span><br><span class="line">  fullscreenButton: <span class="literal">false</span>,</span><br><span class="line">  <span class="comment">//imageryProvider:false,</span></span><br><span class="line">  terrainProvider: xaterrain,</span><br><span class="line">  imageryProvider: tms</span><br><span class="line">&#125;);</span><br><span class="line">viewer.scene.globe.enableLighting = <span class="literal">true</span>;</span><br><span class="line">viewer.scene.debugShowFramesPerSecond = <span class="literal">true</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="参考">参考</h3>
<ol type="1">
<li><a href="https://bertt.wordpress.com/2018/11/26/visualizing-terrains-with-cesium-ii/" target="_blank" rel="noopener">visualizing-terrains-with-cesium-ii</a></li>
<li><a href="https://www.linkedin.com/pulse/fast-cesium-terrain-rendering-new-quantized-mesh-output-alvaro-huarte/" target="_blank" rel="noopener">fast-cesium-terrain-rendering-new-quantized-mesh-output-alvaro-huarte</a></li>
</ol>
]]></content>
      <categories>
        <category>cesium</category>
      </categories>
      <tags>
        <tag>ctb</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>terrain-data-scheduling-for-visualization</title>
    <url>/2020/03/22/terrain-data-scheduling-for-visualization/</url>
    <content><![CDATA[<p>地形四叉树瓦片金字塔数据的调度编程实现上有两种方式，一是建立一个四叉树数据结构，保存瓦片上下层之间的拓扑关系，在一个节点中保存父节点和四个子节点的指针，另一种是用散列映射(hash_map)数据结构，其中瓦片的索引作为键，瓦片的智能指针作为值。四叉树数据结构在调入一个瓦片时必须先生成其父瓦片指针，在删除一个瓦片时必须先删除其所有子瓦片指针，不利于LRU算法的有效实施，而散列映射数据结构则要灵活得多。算法流程图如下所示。 <img src="https://user-images.githubusercontent.com/5879962/47149930-94d4b580-d307-11e8-9acd-5c796495e57a.JPG" alt="data scheduling" /></p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>tile</tag>
        <tag>quadtree</tag>
      </tags>
  </entry>
  <entry>
    <title>visual-studio-shortcut</title>
    <url>/2020/03/21/visual-studio-shortcut/</url>
    <content><![CDATA[<p>vs许多快捷键可用于office软件</p>
<h2 id="代码提示">代码提示</h2>
<p><kbd>Ctrl + J</kbd>激活VS默认代码提示功能。</p>
<h2 id="导入命名空间">导入命名空间</h2>
<p><kbd>Ctrl + .</kbd>方便，复杂点的是<kbd>Alt + Shift + F10</kbd>。 <a id="more"></a> ## 代码选择 ### 区域代码选择 按<kbd>Shift</kbd>选择整（行）块代码，可配合四个方向键（左右键：选择单个字符，上下键：上下行的当前列）、<kbd>Home</kbd>（当前行首）、<kbd>End</kbd>（当前行尾）、<kbd>PgUp</kbd>（当前页首）和<kbd>PgDn</kbd>（当前页尾）使用。</p>
<h3 id="单词逐词选择">单词（逐词）选择</h3>
<p><kbd>Ctrl + Shift +</kbd> 方向键（左键、右键）可一次选择整个单词。</p>
<h2 id="代码删除">代码删除</h2>
<ol type="1">
<li><kbd>Ctrl + Delete</kbd>键，删除光标右边的块（整个单词或一个标点）。</li>
<li><kbd>Ctrl + L</kbd>，删除当前行。</li>
</ol>
<h2 id="滚屏">滚屏</h2>
<p><kbd>Ctrl +</kbd> 方向键上或下，让vs的代码窗口向上或向下翻一行。需要翻的行数过多时，用<kbd>PgUp</kbd>或<kbd>PgDn</kbd>。要回到文档开关<kbd>Ctrl + Home</kbd>，文档结尾<kbd>Ctrl + End</kbd>。</p>
<h2 id="方法函数体折叠">方法（函数）体折叠</h2>
<ul>
<li><kbd>Ctrl + M</kbd>两次</li>
<li><kbd>Ctrl + M + O</kbd>折叠光标所在的类的所有方法体，包括Region等等。</li>
<li><kbd>Ctrl + M + L</kbd>折叠当前类文件中所有的类。</li>
</ul>
<h2 id="代码片段搜索">代码片段搜索</h2>
<p><kbd>Alt + A</kbd>快捷键呼出Bing Code Search(需安装Bing Code Search for C#插件)，<kbd>Ctrl + J</kbd>激活代码提示时也会出现必应代码搜索功能。遇到新API时，有参考代码，无疑比光看MSDN更利于搬砖。</p>
<h2 id="代码窗口管理">代码窗口管理</h2>
<p><kbd>Alt + -</kbd> 激活当前代码窗口的菜单</p>
<h2 id="注释">注释</h2>
<ol type="1">
<li>三个<kbd>/</kbd></li>
<li><kbd>Ctrl + K</kbd>、<kbd>Ctrl + C</kbd>注释，<kbd>Ctrl + K</kbd>、<kbd>Ctrl + U</kbd>反注释。</li>
</ol>
<h2 id="切换代码窗口">切换代码窗口</h2>
<p>使用<kbd>Ctrl + Tab</kbd>激活该窗口后，按住<kbd>Ctrl</kbd>键不放，使用<kbd>Tab</kbd>或<kbd>Shift + Tab</kbd>或方向键可进行导航。 ## 跳转到指定行 和word一样的用法，<kbd>Ctrl + G</kbd>。 ## 代码阅读导航 看代码时经常会跳转到不同的类文件中，有时想按跳转的顺序一步步返回，可以按<kbd>Ctrl + -</kbd>，完成后退操作，<kbd>Ctrl + Shift + -</kbd>前进。</p>
]]></content>
      <categories>
        <category>software</category>
        <category>visual studio</category>
      </categories>
      <tags>
        <tag>visual studio</tag>
      </tags>
  </entry>
  <entry>
    <title>pandoc-setting</title>
    <url>/2020/03/20/pandoc-setting/</url>
    <content><![CDATA[<h2 id="安装">安装</h2>
<p>Windows 10系统中，需要首先从官网下载msi文件进行安装</p>
<h2 id="hexo设置">hexo设置</h2>
<h3 id="更换渲染引擎">更换渲染引擎</h3>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm un hexo-renderer-marked --save</span><br><span class="line">npm i hexo-renderer-pandoc --save</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="next主题配置">Next主题配置</h3>
<p>在Next主题的配置文件 _config.yml中设置mathjax为true： <figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Math Formulas Render Support</span></span><br><span class="line"><span class="attr">math:</span></span><br><span class="line">  <span class="comment"># Default (true) will load mathjax / katex script on demand.</span></span><br><span class="line">  <span class="comment"># That is it only render those page which has `mathjax: true` in Front-matter.</span></span><br><span class="line">  <span class="comment"># If you set it to false, it will load mathjax / katex srcipt EVERY PAGE.</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># hexo-renderer-pandoc (or hexo-renderer-kramed) required for full MathJax support.</span></span><br><span class="line">  <span class="attr">mathjax:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># See: https://mhchem.github.io/MathJax-mhchem/</span></span><br><span class="line">    <span class="attr">mhchem:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># hexo-renderer-markdown-it-plus (or hexo-renderer-markdown-it with markdown-it-katex plugin) required for full Katex support.</span></span><br><span class="line">  <span class="attr">katex:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># See: https://github.com/KaTeX/KaTeX/tree/master/contrib/copy-tex</span></span><br><span class="line">    <span class="attr">copy_tex:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure> mathjax 和 katex 是互斥的两个选项，enable 不能同时 true或 false。</p>
<h3 id="文章配置">文章配置</h3>
<p>在每篇博文开头之处，添加 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mathjax: true</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>mathjax</tag>
        <tag>latex</tag>
      </tags>
  </entry>
  <entry>
    <title>quaternion</title>
    <url>/2020/03/19/quaternion/</url>
    <content><![CDATA[<h2 id="复数">复数</h2>
<p>欧拉公式： <span class="math display">\[\begin{equation}
\begin{aligned}
z&amp;=x+y\\&amp;=rcos{\theta}+rsin{\theta}i\\&amp;=re^{i{\theta}}
\end{aligned}
\end{equation}\]</span> 单位复数乘法可以达到一个二维旋转的效果。 <a id="more"></a></p>
<h2 id="四元数">四元数</h2>
<h3 id="四元数的定义">四元数的定义</h3>
<p>从复数推导四元数： <span class="math display">\[\begin{equation}
\begin{aligned}
e^{\textbf{i}\cdot\hat{\textbf{n}}\frac{\theta}{2}}&amp;=cos{\frac{\theta}{2}}+\textbf{i}\cdot\hat{\textbf{n}}sin{\frac{\theta}{2}}\\
&amp;=q_w+\textbf{i}\cdot\textbf{q}_v\\
&amp;=q_w+q_xi+q_yj+q_zk
\end{aligned}
\end{equation}\]</span> 将复数的一个虚部换成三个虚部，<span class="math inline">\(\textbf{i} = (i,j,k)\)</span>，且两两相交。<span class="math inline">\(\hat{\textbf{n}}\)</span>为三维的单位向量，这便是四元数的常规表达形式,定义为： <span class="math display">\[\textbf{q}=q_w+q_xi+q_yj+q_zk\]</span>一个四元数有一个实部和三个虚部，三个虚部之间满足如下关系。 <span class="math display">\[\left\{\begin{matrix}
i^{2}=j^{2}=k^{2}=-1\\
ij=-ji=k\\
jk=-kj=i\\
ki=-ik=j
\end{matrix}\right.\]</span> 或者也用一个标量和一个向量来表达四元数： <span class="math display">\[\mathbf{q} = \left[ q_w, \mathbf{q}_v \right], \quad q_w \in \mathbb{R}, \mathbf{q}_v = [q_x, q_y, q_z] \in \mathbb{R}^3.\]</span> 这里，标量<span class="math inline">\(\mathbf{q}_w\)</span>称为四元数的实部，而向量<span class="math inline">\(\mathbf{q}_v\)</span>称为它的虚部。如果一个四元数虚部为0，称之为实四元数。反之，若它的实部为0，称之为虚四元数(纯四元数)，是四维空间在<span class="math inline">\(q_w=0\)</span>时的一个子空间的点，形式为<span class="math inline">\(\{0, \textbf{q}_v\}\)</span>。该定义和复数是相似的。</p>
<h3 id="四元数的理解">四元数的理解</h3>
<h4 id="矩阵及旋转">矩阵及旋转</h4>
<p>矩阵表示的是一个空间向另一个空间转换的变换关系。三维空间的旋转变换由旋转后的空间在世界空间的三个基来表示。假如某个点绕Z轴旋转α角，也就是说旋转后的Z坐标是不变的，变化的只是X、Y坐标，可以写出下面这个式子： <span class="math display">\[\begin{pmatrix}
x^{&#39;}\\ 
y^{&#39;}\\
z
\end{pmatrix}=\begin{pmatrix}
cos\alpha &amp; -sin\alpha &amp; 0\\ 
sin\alpha &amp; cos\alpha &amp; 0\\
0 &amp; 0 &amp; 1
\end{pmatrix}\begin{pmatrix}
x\\ 
y\\
z
\end{pmatrix}\]</span> 这个式子中的系数矩阵可以记为如下形式: <span class="math display">\[R_{Z}(\alpha)=\begin{pmatrix}
cos\alpha &amp; -sin\alpha &amp; 0\\ 
sin\alpha &amp; cos\alpha &amp; 0\\
0 &amp; 0 &amp; 1
\end{pmatrix}\]</span> 将<span class="math inline">\(R_Z\)</span>称为旋转矩阵。同样可推出：</p>
<p><span class="math display">\[\begin{matrix}
R_{X}(\alpha)=\begin{pmatrix}
1 &amp; 0 &amp; 0\\
0 &amp; cos\alpha &amp; -sin\alpha\\
0 &amp; sin\alpha &amp; cos\alpha
\end{pmatrix}\\
R_{Y}(\alpha)=\begin{pmatrix}
cos\alpha &amp; 0 &amp; sin\alpha\\
0 &amp; 1 &amp; 0\\
-sin\alpha &amp; 0 &amp; cos\alpha
\end{pmatrix}\end{matrix}\]</span> 矩阵旋转使用了一个4*4大小的矩阵来表示绕任意轴旋转的变换矩阵，而欧拉选择则是按照一定的坐标轴顺序（例如先x、再y、最后z），每个轴旋转一定角度来变换坐标或向量，它实际上是一系列坐标轴旋转的组合，比如： <span class="math display">\[R = R_{Z}(\alpha)R_{Y}(\beta)R_{X}(\gamma)=\begin{pmatrix}
cos\alpha cos\beta &amp; cos\alpha sin\beta sin\gamma - sin\alpha cos\gamma &amp; cos\alpha sin\beta cos\gamma + sin\alpha sin\gamma\\ 
sin\alpha cos\beta &amp; cos\alpha cos\gamma + sin\alpha sin\beta sin\gamma &amp; sin\alpha sin\beta cos\gamma - sin\gamma cos\alpha\\ 
-sin\beta &amp; cos\beta sin\gamma &amp; cos\beta cos\gamma
\end{pmatrix}\]</span></p>
<p>OpenGL中如果已经通过鼠标或者键盘得到了 yaw、pitch 和 roll 的值，就可以通过类似下面的方法计算得到 view 矩阵。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">glm::mat4 <span class="title">CalculateView</span><span class="params">(<span class="keyword">float</span> yaw, <span class="keyword">float</span> pitch, <span class="keyword">float</span> roll, glm::vec3 eye_pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> glm::mat4 matRoll  = glm::rotate(matRoll,  roll,  glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>));</span><br><span class="line"> glm::mat4 matPitch = glm::rotate(matPitch, pitch, glm::vec3(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line"> glm::mat4 matYaw   = glm::rotate(matYaw,  yaw,    glm::vec3(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 顺序是非常重要的</span></span><br><span class="line"> glm::mat4 rotate =  matYaw * mattRoll * matPitch;</span><br><span class="line"></span><br><span class="line"> glm::mat4 translate = glm::translate(translate, -eye_pos);</span><br><span class="line"></span><br><span class="line"> viewMatrix = rotate * translate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>旋转到一定程度，某一个轴可以被其他两个轴线性表示，那么就缺失了一个维度，产生了万向节死锁。只要使用矩阵来表示旋转，就有发生万向节死锁的风险。</p>
<h4 id="用四元数表示旋转">用四元数表示旋转</h4>
<p>一个四元数可以和一个矩阵旋转对应。使用四元数来表示旋转有多方面的原因：</p>
<ul>
<li>解决万向节死锁问题</li>
<li>更少的存储空间（4 floats vs 16 floats）</li>
<li>绕任意轴旋转非常方便，而旋转矩阵实现非常复杂</li>
<li>方便追踪旋转</li>
<li>旋转结合时计算量较少，无论是求逆、串联等操作，相比矩阵更加高效</li>
<li>方便平滑插值，而旋转矩阵的实现方法不能保证绝对平滑</li>
</ul>
<p>还有一种说法是解决向量乘法，向量之间乘法有内积和外积，但这两个运算均不完美，即不满足群的条件（当然四元数诞生的时候也还没有内积外积的说法）。那向量之间是否存在这样一个非常完美的乘法，于是三维空间无法解决的问题就映射到四维空间。这便是四元数诞生的契机。四元数并不是生来为了解决三维旋转，而是它的性质非常有利于表达旋转信息。</p>
<p>基础概念：</p>
<p><strong>空间和子空间的映射</strong> 我们将二维空间表示为(x,y)，当y=0时，其实可以看成是一维的，只不过它表示成(x,0)这种形式。推到四维，(w,x,y,z)，当w=0时，(0,x,y,z)就是一个三维子空间，这也是为什么我们可以用单位四元数对三维向量进行操作，其实我们是将三维向量映射到四维的三维子空间（w=0，这种形式也称纯四元数），然后对其进行旋转，最终得到的向量结果依然是这个三维子空间中的，因而可以映射回三维空间。</p>
<p><strong>广义球</strong> 这里的球是广义上的。我们在二维平面上，广义球其实指代circle，三维空间上就是我们认知上的球，称为two-sphere，而四维空间中广义球其实是一个超球（hyper-sphere），又称为three-sphere。单位向量其实就是广义球上面的点，而单位四元数也就是three-sphere上面的点。</p>
<p><strong>约束与特征向量</strong> 空间中的一点由x, y, z等参数来表示，一般来说参数的数量与维数相等，二维空间的点用{x, y}参数，四维空间的点用{x, y, z, w}参数。但是对于空间的点加以约束，则会减少参数的数量，比如三维空间的点在某一单位球面上，原本三个参数{x, y, z}才能表达的点现在只需要两个参数{u, v}就可以表达。如果{u, v}是单位向量，也可以称{u, v}是{x, y, z}的特征向量。</p>
<p><strong>空间映射理解</strong> <span class="math inline">\(x^{2}+y^{2}+z^{2}+w^{2}=1\)</span>中取x、y和z来表示超球。四维空间投影到三维超平面（w=0）可能是一个two-sphere。当投影点在整个two-sphere的边缘时，w一定为0，值得一提的是在这个空间内的四元数是一个纯四元数。当投影点落在two-sphere的内部时，也分为两种情况，w&gt;0和w&lt;0。但是可以发现这两种情况下对应的特征向量是一样的，所以将旋转矩阵向四元数转换时，是有两个对应值的，四元数的范围是2倍覆盖于3D旋转（2:1 mapping）。</p>
<p>四元数作为四维空间中一个超球上面的点，主要用于描述3D旋转。在复数域<span class="math inline">\(\mathbb{C}\)</span>，可以用一个复数<span class="math inline">\(e^{i\theta}\)</span>表示2D的旋转，类似的，3D空间也可以用单位四元数表示旋转。假设某个旋转是绕单位向量<span class="math inline">\(\mathbf{\hat{n}}=[n_x,n_y,n_z]^T\)</span>进行了角度为θ的旋转，那么这个旋转的四元数形式为： <span class="math display">\[\begin{equation}
\mathbf{q} = \left[\cos\frac{\theta}{2},n_x\sin\frac{\theta}{2}, n_y\sin\frac{\theta}{2}, n_z\sin\frac{\theta}{2}\right]^T
\end{equation}\]</span> 这是一个模长为1的单位四元数，实部是<span class="math inline">\(cos\frac{θ}{2}\)</span>，虚部有3个，两两互相正交，为一个单位轴乘以<span class="math inline">\(sin\frac{θ}{2}\)</span>。若四元数长度不为1，可以通过归一化转换为模长为1的四元数。式中的θ加上2π，得到一个相同的旋转，但此时对应的四元数变成了−q。因此在四元数中，任意的旋转都可以由两个互为相反数的四元数表示。同理，取θ为0，则得到一个没有任何旋转的四元数：<span class="math inline">\(\begin{equation}\mathbf{q}_0=\left[{\pm1,0,0,0}\right]^T\end{equation}\)</span>。 齐次形式<span class="math inline">\((w,x,y,z)\)</span>的四元数满足<span class="math inline">\(x^{2}+y^{2}+z^{2}+w^{2}=1\)</span>，有 <span class="math display">\[\left\{\begin{matrix}
x = n_{x}sin\frac{\theta}{2}\\
y = n_{y}sin\frac{\theta}{2}\\
z = n_{z}sin\frac{\theta}{2}\\
w = cos\frac{\theta}{2}
\end{matrix}\right.\]</span> 由于存在<span class="math inline">\(x^{2}+y^{2}+z^{2}+w^{2}=1\)</span>这个约束，四元数的自由度其实只有3，且每个四元数可以对应一个特征向量，即<span class="math inline">\(\hat{\textbf{n}}\)</span>。四元数并不是与特征向量一一对应的。 假设有一个空间三维点<span class="math inline">\(\mathbf{v} = [x,y,z]\in \mathbb{R}^3\)</span>，以及一个由旋转轴和夹角<span class="math inline">\(\mathbf{n},\theta\)</span> 指定的旋转。用一个虚四元数来描述该空间三维点：<span class="math inline">\(\mathbf{p} = [0, x, y, z] = [0, \mathbf{v}]\)</span>。然后用另一个四元数表示这个旋转：<span class="math inline">\(\mathbf{q}=[\cos \frac{\theta}{2}, \mathbf{n} \sin \frac{\theta}{2} ]\)</span>，那么旋转后的点<span class="math inline">\(\mathbf{p}&#39;\)</span>即可表示为这样的乘积： <span class="math display">\[\begin{equation} \mathbf{p}&#39; = \mathbf{q} \mathbf{p} \mathbf{q}^{-1} \end{equation}\]</span> 可以验证，计算结果的实部为<span class="math inline">\(\mathbf{n}^T(\mathbf{n} \times \mathbf{v})=0\)</span>，故计算结果为纯虚四元数。其虚部的三个分量表示旋转后3D点的坐标。</p>
<h3 id="四元数的运算">四元数的运算</h3>
<p>四元数和通常复数一样，可以进行一系列的运算。常见的有四则运算、内积、求逆、共轭、求指数／对数等等。表示姿态时，它还可以进行插值。 现有两个四元数<span class="math inline">\(\mathbf{q}_a,\mathbf{q}_b\)</span>，它们的向量表示为<span class="math inline">\([s_a, \mathbf{v}_a], [s_b, \mathbf{v}_b]\)</span>，或者原始四元数表示为<span class="math inline">\(s_a+x_ai+y_aj+z_ak, s_b+x_bi+y_bj+z_bk.\)</span>，则有：</p>
<ul>
<li>加减法 <span class="math display">\[\begin{equation} \mathbf{q}_a \pm \mathbf{q}_b = \left[ s_a \pm s_b, \mathbf{v}_a \pm \mathbf{v}_b \right]\end{equation}\]</span></li>
<li>乘法
$$\begin{equation} \begin{array}{lll} \mathbf{q}_a \mathbf{q}_b &=&  {s_a}{s_b} - {x_a}{x_b} - {y_a}{y_b} - {z_a}{z_b}\\   &&+ \left( {{s_a}{x_b} + {x_a}{s_b} + {y_a}{z_b} - {z_a}{y_b}} \right)i\\   &&+ \left( {{s_a}{y_b} - {x_a}{z_b} + {y_a}{s_b} + {z_a}{b_b}} \right)j\\   &&+ \left( {{s_a}{z_b} + {x_a}{y_b} - {x_b}{y_a} + {z_a}{s_b}} \right)k  \end{array} \end{equation}$$ 写成向量形式并利用内外积运算表达： <span class="math display">\[\begin{equation} \mathbf{q}_a \mathbf{q}_b = \left[ s_a s_b - \mathbf{v}_a \cdot \mathbf{v}_b, s_a\mathbf{v}_b + s_b\mathbf{v}_a + \mathbf{v}_a \times \mathbf{v}_b \right] \end{equation}\]</span> 在该乘法定义下，两个实的四元数乘积仍是实的，这与复数也是一致的。然而，注意到，由于最后一项外积的存在，该乘法通常是不可交换的，除非<span class="math inline">\(\mathbf{v}_a\)</span>和<span class="math inline">\(\mathbf{v}_b\)</span>在<span class="math inline">\(\mathbb{R}^3\)</span>中共线。</li>
<li>模长 四元数的模长定义为： <span class="math display">\[\begin{equation}  \| \mathbf{q}_a \| = \sqrt{ s_a^2 + x_a^2 + y_a^2 + z_a^2 } = \sqrt{\mathbf{q}_a^{*T} \mathbf{q}_a} \end{equation}\]</span> 可以验证，两个四元数乘积的模即为模的乘积。这保证单位四元数相乘后仍是单位四元数。 <span class="math display">\[\begin{equation}  \| \mathbf{q}_a \mathbf{q}_b \| = \|\mathbf{q}_a \| \| \mathbf{q}_b \| \end{equation}\]</span></li>
<li>逆 <span class="math display">\[\begin{equation} \mathbf{q}^{-1} = \mathbf{q}^* / \| \mathbf{q} \| ^2 \end{equation}\]</span> 按此定义，四元数和自己的逆的乘积为实四元数的1： <span class="math display">\[\begin{equation} \mathbf{q} \mathbf{q}^{-1} = \mathbf{q}^{-1} \mathbf{q} = 1 \end{equation}\]</span> 同时，乘积的逆有和矩阵相似的性质： <span class="math display">\[\begin{equation}  \left( \mathbf{q}_a \mathbf{q}_b \right)^{-1} = \mathbf{q}_b^{-1} \mathbf{q}_a^{-1} \end{equation}\]</span> 对于单位四元数，即<span class="math inline">\(\|\mathbf{q}\|=1\)</span>，它的逆即是它的共轭四元数。</li>
<li>数乘与点乘 和向量相似，四元数可以与数相乘： <span class="math display">\[\begin{equation}  k \mathbf{q} = \left[ ks, k\mathbf{v} \right] \end{equation}\]</span> 点乘是指两个四元数每个位置上的数值分别相乘： <span class="math display">\[\begin{equation} \mathbf{q}_a \cdot \mathbf{q}_b = s_a s_b + x_a x_b i + y_a y_b j + z_a z_b k \end{equation}\]</span></li>
</ul>
<h3 id="四元数到旋转矩阵的转换">四元数到旋转矩阵的转换</h3>
<p>由于任意单位四元数都可表示为一个3D旋转，即SO(3)中的元素，我们可以找到一个旋转矩阵与之对应。最简单的方式是由四元数q解出旋转角θ和旋转轴n，但那样要计算一个arccos函数，代价较大。实际上这个计算是可以通过一定的计算技巧绕过的。为省略篇幅，我们直接给出四元数到旋转矩阵的转换方式。 <span class="math display">\[\begin{equation} \mathbf{R} = \left[ {\begin{array}{*{20}{c}} {1 - 2q_2^2 - 2q_3^2}&amp;{2{q_1}{q_2} + 2{q_0}{q_3}}&amp;{2{q_1}{q_3} - 2{q_0}{q_2}}\\ {2{q_1}{q_2} - 2{q_0}{q_3}}&amp;{1 - 2q_1^2 - 2q_3^2}&amp;{2{q_2}{q_3} + 2{q_0}{q_1}}\\ {2{q_1}{q_3} + 2{q_0}{q_2}}&amp;{2{q_2}{q_3} - 2{q_0}{q_1}}&amp;{1 - 2q_1^2 - 2q_2^2} \end{array}} \right] \end{equation}\]</span> 反之，由旋转矩阵到四元数的转换如下。假设矩阵为<span class="math inline">\(\mathbf{R}=\{ m_{ij}\}, i, j \in \left[ 1, 2,3 \right]\)</span>，其对应的四元数q由下式给出： $$\begin{equation} {q_0} = \frac{{\sqrt {tr(R) + 1} }}{2},{q_1} = \frac{{{m_{23}} - {m_{32}}}}{{4{q_0}}},{q_2} = \frac{{{m_{31}} - {m_{13}}}}{{4{q_0}}},{q_3} = \frac{{{m_{12}} - {m_{21}}}}{{4{q_0}}} \end{equation}$$ 其中tr(R)表示R矩阵的迹，也即矩阵R的主对角线（从左上方至右下方的对角线）上各个元素的总和。由于q和−q表示同一个旋转，事实上一个R的四元数表示并不是惟一的。存在其他三种与上式类似的计算方式，而本书省略了。实际编程中，当q0接近0时，其余三个分量会非常大，导致解不稳定，此时会考虑使用剩下的几种方式计算。</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://www.cnblogs.com/gaoxiang12/p/5120175.html" target="_blank" rel="noopener">视觉SLAM中的数学基础 第二篇 四元数</a></li>
<li><a href="http://www.selfgleam.com/quaternion-camera.html" target="_blank" rel="noopener">四元数相机</a></li>
<li><a href="http://zhaoxuhui.top/blog/2018/03/13/RelationBetweenQ4&amp;R&amp;Euler.html" target="_blank" rel="noopener">欧拉角、四元数、旋转矩阵推导及相互关系</a></li>
<li><a href="https://krasjet.github.io/quaternion/quaternion.pdf" target="_blank" rel="noopener">四元数与三维旋转</a></li>
<li><a href="https://eater.net/quaternions" target="_blank" rel="noopener">Visualizing quaternions</a></li>
</ul>
]]></content>
      <categories>
        <category>math</category>
      </categories>
      <tags>
        <tag>四元数</tag>
      </tags>
  </entry>
  <entry>
    <title>epsg-4326-vs-3857</title>
    <url>/2020/03/19/epsg-4326-vs-3857/</url>
    <content><![CDATA[<h2 id="基准">基准</h2>
<p>每种地图和空间数据集都有一个大地基准，而且在地球的不同地方使用着不同的基准。基准是基于特定椭球体的地理坐标系，原点位于特定位置。NOAA的<a href="https://www.ngs.noaa.gov/corbin/class_description/NGS_Datums_vid1/" target="_blank" rel="noopener">视频</a>中较好的介绍了基准的概念。 <a id="more"></a></p>
<h2 id="epsg-4326">EPSG 4326</h2>
<p>即WGS84，由GeoJSON定义，以经纬度表示。无法在二维平面地图上可视化WGS84坐标系，大多数软件程序使用等角投影（Plate-Carrée）投影这些坐标（Esri使用EPSG：54001）。</p>
<h2 id="epsg-3857">EPSG 3857</h2>
<p>采用WGS84坐标系并将其投影到正方形上。在大多数情况下，网络地图依赖于以WGS84坐标存储的数据（在某些程序中称为“非投影”数据），然后使用Pseudo-Mercator可视化数据。 如上所述，WGS84是未投影的，该数据没有可视化表示。 因此如果说要在WGS84中查看其数据，则实际上是希望在Plate-Carrée投影中查看其数据，该投影实际上在页面创建了线性笛卡尔图。</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://lyzidiamond.com/posts/4326-vs-3857" target="_blank" rel="noopener">epsg 4326 vs 3857(projection etc)</a></li>
</ul>
]]></content>
      <categories>
        <category>map</category>
      </categories>
      <tags>
        <tag>epsg</tag>
        <tag>datum</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo-git-deploy</title>
    <url>/2020/03/18/hexo-git-deploy/</url>
    <content><![CDATA[<h2 id="git-hook方式">git hook方式</h2>
<h3 id="本地">本地</h3>
<p>本地部署工具</p>
<p><code>npm install hexo-deployer-git --save</code></p>
<p>在hexo站点配置文件_config.yml中添加deploy参数： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- type: git</span><br><span class="line">  repo: git@vps-ip:&#x2F;home&#x2F;git&#x2F;hexo.git</span><br></pre></td></tr></table></figure> <a id="more"></a></p>
<h3 id="服务端">服务端</h3>
<p>服务端添加用户</p>
<p><code>adduser git</code></p>
<p>设置用户权限，在/etc/sudoers中增加如下内容： <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">## Allow root to run any commands anywhere</span></span><br><span class="line">root    ALL=(ALL)     ALL</span><br><span class="line">git   ALL=(ALL)     ALL //添加一行git用户权限</span><br></pre></td></tr></table></figure> 同时增加git用户对相关文件夹的读写权限： <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">chown git:git -R /home/git</span><br><span class="line">chown git:git -R /var/www/html</span><br></pre></td></tr></table></figure> 然后将本地ssh公钥上传，并在服务端建立网页共享git库。 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mkdir /home/git/.ssh &amp;&amp; <span class="built_in">cd</span> /home/git/.ssh</span><br><span class="line">vim authorized_keys</span><br><span class="line">mkdir /home/git/hexo.git</span><br><span class="line"><span class="built_in">cd</span> /home/git/hexo.git</span><br><span class="line">git init --bare</span><br></pre></td></tr></table></figure> 接着配置hooks</p>
<p><code>vim hooks/post-receive</code></p>
<p>添加如下内容： <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">git --work-tree=/var/www/html --git-dir=/home/git/hexo.git checkout -f</span><br></pre></td></tr></table></figure> 设置权限</p>
<p><code>chmod +x post-receive</code></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>cesium-ctb-terrain-gen</title>
    <url>/2020/03/18/cesium-ctb-terrain-gen/</url>
    <content><![CDATA[<h2 id="下载tif">下载tif</h2>
<h3 id="可用网站">可用网站</h3>
<ul>
<li><a href="https://worlddem-database.terrasar.com/" target="_blank" rel="noopener">AIRBUS worldDEM-terrasar</a></li>
<li><a href="http://dwtkns.com/srtm30m/" target="_blank" rel="noopener">srtm30m</a></li>
<li><a href="http://dwtkns.com/srtm/" target="_blank" rel="noopener">srtm90m</a></li>
<li><a href="https://scihub.copernicus.eu/dhus/#/home" target="_blank" rel="noopener">ESA哥白尼计划</a></li>
<li><a href="https://earthexplorer.usgs.gov/" target="_blank" rel="noopener">USGS-earthexplorer</a></li>
<li><a href="https://prd-tnm.s3.amazonaws.com/index.html?prefix=StagedProducts/Elevation/1m/IMG/" target="_blank" rel="noopener">USGS-NED-1m-db in USA</a></li>
<li><a href="https://viewer.nationalmap.gov/basic/?basemap=b1&amp;category=ned,nedsrc&amp;title=3DEP%20View" target="_blank" rel="noopener">USGS-nationalmap-3DEP</a></li>
<li><a href="https://eos.com/landviewer/?lat=34.26368&amp;lng=109.19109&amp;z=11" target="_blank" rel="noopener">earth observing system-landviewer</a></li>
<li><a href="https://search.asf.alaska.edu" target="_blank" rel="noopener">NASA阿拉斯加卫星设施</a></li>
<li><a href="https://nsidc.org/data/highmountainasia/data-summaries" target="_blank" rel="noopener">NASA青藏高原8m</a></li>
<li><a href="https://www.eorc.jaxa.jp/ALOS/en/aw3d30/index.htm" target="_blank" rel="noopener">AW3D30</a></li>
<li><a href="http://freegisdata.rtwilson.com/" target="_blank" rel="noopener">others</a> <a id="more"></a></li>
</ul>
<h2 id="处理tif">处理tif</h2>
<p>使用ArcMap QGIS等工具，合成tif瓦片，设置pixeltype数据类型float为int，再设置nodata值为0。</p>
<h2 id="生成terrain">生成terrain</h2>
<h3 id="ctb下载编译">ctb下载编译</h3>
<h3 id="使用ctb生成terrain文件">使用ctb生成terrain文件</h3>
<p>注：生成时间长，数据量大。</p>
]]></content>
      <categories>
        <category>cesium</category>
      </categories>
      <tags>
        <tag>ctb</tag>
        <tag>terrain</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/03/17/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="quick-start">Quick Start</h2>
<h3 id="create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="run-server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
<h3 id="use-next-theme">Use next theme</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-theme-next themes&#x2F;next</span><br></pre></td></tr></table></figure>
<p>in _config.yml, set <code>theme: next</code>.</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
</search>
